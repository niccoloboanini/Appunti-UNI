# ALGORITMI DI ROUTING

### ROUTING
- Instradamento 
Permette di mettere in comunicazione una sorgente con una destinazione - individuando i percorsi piÃ¹ tra tutte le alternative

Effettuata da un Router

### ATTIVITA' DI UN ROUTER
Due step:

1) Ricerca destinazione: interpretare l'indirizzo a cui si deve inoltrare il pacchetto (e quindi individuare la porta di uscita)
2) Inoltro (forwarding) $\to$ trasmissione effettiva dei bit nella uscita selezionata

## ALGORITMI DI ROUTING
Si cercano metodi/algoritmi che siano:
 - semplici da realizzare
 - robusti (affidabili)
 - stabili
 - ottimi (secondo alcuni criteri)

Le tecniche di routing si possono dividere nel seguente modo:
- Implementazione caratteristica
	- Tipologia algoritmo
		- Ulteriori tipologie
![[Pasted image 20220719193146.png|500]]
**- Senza Tabella** $\to$ senza interrogazione del database locale
	- Random
	- Flooding
	- Source Routing
- **Gerarchico** (cfr. rete telefonica)
**- Con Tabella** $\to$ il router ha un database dove sono contenute le info utili per il routing
	- Dinamico
		- Distance Vector
		- Link State
	- Statico (stesse organizzazioni)


Sistema:
- **Centralizzato**: esiste un dispositivo (anche cloud) che sceglie quale algoritmo usare e collabora con i vari dispositivi
- **Distribuito**: piÃ¹ elementi che gestiscono il routing che cooperano per definire le strategie di routing migliori
- **Isolata**: un router in maniera individuale decide cosa fare (decisioni da prendere tipo algoritmo di routing)

---
## SENZA TABELLA

### ALGORITMO RANDOM
Si selezione su base  random su quale porta disponibile nel router andare a ripetere il messaggio ricevuto (escludendo quella da cui il messaggio Ã¨ arrivato)
![[Pasted image 20220719195806.png|400]]
- E' robusto perchÃ© se si guasta qualche link basta toglierlo dalle possibili scelte, ma l'algoritmo funziona lo stesso ðŸ˜ƒ
- Non Ã¨ ottimo perchÃ© la scelta Ã¨ quasi randomica quindi non sarÃ  facile statisticamente trovare quella ottima ðŸ˜¡
- Semplice da realizzare ðŸ˜ƒ
- Senza tabella: l'azione viene eseguita senza passare dalla consultazione di un database locale (quindi anche veloce) ðŸ˜ƒ

### FLOODING
Si ripete un messaggio su tutte le porte di uscita (escludendo quella da cui arriva)
- Semplice (il piÃ¹ semplice di tutti) ðŸ˜ƒ
- Rischio di inondazione $\to$ allora si imposta un TTL per limitare (cfr. appunti precedenti) ðŸ˜¡
- Sicuro ðŸ˜ƒ
	- Utilizzato per questo dove si vuol privilegiare la sicurezza che un messaggio arrivi a destinazione rispetto che la velocitÃ /prestazione
		- Ad esempio nelle reti militari (poco estese e necessariamente sicure)

### SOURCE ROUTING
Metodo che puÃ² essere implementato con due modalitÃ :
- Centralizzata ($path \ server$): ogni nodo che ha bisogno di inviare un messaggio verso una certa destinazione pone la richiesta al "cloud" ($sink$/apparato centrale). Quest'ultimo ha giÃ  costruito tutte le possibili rotte che puÃ² gestire e trasferisce al nodo le migliori informazioni per gestire il routing
- Isolata ($path \ discovery$): direttamente il nodo interessato capisce qual Ã¨ la rotta da seguire - questo gli Ã¨ permesso effettuando prima il $discovery$ (scoperta) mandando un *pacchetto esploratore* che viene inoltrato nella rete con modalitÃ  $floating$ con $\text{TTL}=1$ (massimo una ripetizione) $\to$ si scopre il path migliore
	- Viaggiano molte copie del pacchetto esploratore sulla rete: una di queste arriverÃ  alla destinazione cercata
	- Ogni volta che il pacchetto visita un nodo viene scritto sull'$header$ il nome del pacchetto ch ha visitato
	- Quando il pacchetto arriva alla destinazione c'Ã¨ la "cronologia dei nodi", quindi basterÃ  ripercorrerla in maniera opposta per scoprire ufficialmente anche dal punto di vista del nodo sorgente il percorso migliore
		- Si considera come rotta migliore quella che arriva prima


---
## ALGORITMI CON TABELLA
Un nodo quando riceve un pacchetto se lo salva/copia nel proprio database locale, dopo aver controllato che in esso non fosse giÃ  presente (abbinamenti indirizzo sorgete indirizzo destinazione)
- PiÃ¹ efficiente ðŸ˜ƒ âœ…
- PiÃ¹ impegnativo (quindi anche piÃ¹ lento) ðŸ˜¡

I due algoritmi che mostreremo sono molto simili tra loro:
- Entrambi arrivano (in modo diverso) alla soluzione ottima
- La differenza principale riguarda la modalitÃ  attuativa di realizzare la cooperazione tra i nodi

### DISTANCE VECTOR
- Ogni nodo si interfaccia (coopera) con i nodi direttamente connessi (detti "nodi vicini") su base $link \text{-} to \text{-} link$.
	- Ogni nodo trasferisce la propria tabella di routing (condividendola) con i propri vicini

Nella tabella di routing c'Ã¨ un campo $next \text{-} hop$: ovvero il router del passaggio successivo a cui inviare il pacchetto (affinchÃ© poi arrivi alla destinazione finale)
	Non c'Ã¨ scritto tutto il percorso, c'Ã¨ solo il router vicino
		(nota: se non ci sono vicini si sceglie un router di default)

L'algoritmo puÃ² essere enunciato in questo modo:
> Trovare percorsi a costo minimo partendo da un nodo sorgente e selezionando i successivi progressivamente 

##### COSTO
Valore di riferimento assegnato a un collegamento con l'obiettivo di costruire un percorso sorgente-destinazione che abbia tale valore minore (costo minore)
- PuÃ² essere legato al tempo, al numero totale di nodi, all'affidabilitÃ  etc...
	- L'importante Ã¨ stabilirne uno per individuare l'alternativa migliore in un certo contesto

Ad esempio:
- Per fare $\text{A}\to B$ conviene il collegamento diretto
- Per fare $\text{A} \to \text{C}$ non conviene il collegamento diretto ma conviene fare $\text{A} \to \text{B} \to \text{C}$
![[Pasted image 20220719222410.png|250]]

#### ESECUZIONE
Vediamo l'esecuzione dell'algoritmo con un esempio
- Sono noti i costi dei links
![[Pasted image 20220719223503.png|350]]
Passaggi:
- Si sceglie un nodo di partenza, ad esempio $\text{A}$
- Si prende il nodo connesso al nodo di partenza con costo minore, e lo si considera parte di $\text{A}$. In altre parole, in questo caso: $\text{A} \longleftarrow \text{C}$
	- Si ripete lo stesso per ogni nodo, e si condividono le tabelle
- Quando $\text{C}$ condivide la sua tabella con $\text{A}$, quest'ultimo acquisisce una visione che prima non aveva (piÃ¹ profonda). In questo modo comincia a verificare se passando da $\text{C}$ riesce a migliorare alcuni path verso altri nodi (in termini di costo)
	- In questo caso ad esempio $\text{A}$ scopre che puÃ² raggiungere $\text{E}$ con un costo totale di $6$, che probabilmente sarÃ  un costo minimo (ancora perÃ² deve verificare tutti i percorsi per la conferma - perÃ² intanto segna sulla tabella)
- Si continuano a scambiare tabelle finchÃ© queste non subiscono piÃ¹ cambiamenti, ovvero si arriva a una *soluzione stabile*

![[Pasted image 20220719223520.png|500]]

##### ESEMPIO DI AGGIORNAMENTO DI UNA TABELLA
Vediamo la procedura effettiva di scambio (condivisione) delle tabelle:
- Sappiamo che ogni $tot$ i nodi si scambiano le tabelle 
- Nel seguente caso, $\text{C}$ manda ad $\text{A}$ l'aggiornamento della propria tabella
- Ora, $\text{A}$ deve aggiornare questi valori sommando a tutti costi di raggiungimento relativi $C\to \text{?}$ (ovvero a tutte le righe della tabella) i costi di  $\text{A} \to \text{C}$.
	- In questo caso si somma $2$ essendo $\text{A} \to \text{C}=2$
- Viene quindi comparata la nuova tabella di $\text{A}$ con quella vecchia e se ne crea una "ibrida" composta dai valori migliori relativi a ciascuna riga
	- In questo caso si ha un miglioramento solo nella ultima e quinta riga, che permette ad $\text{A}$ di raggiungere $\text{E}$ (che prima era irraggiungibile, ovvero con costo $\infty$) con un costo $6$
![[Pasted image 20220719224257.png|400]]

Proseguendo con questo su tutti i nodi si ottiene un $albero$ (dei costi minimi)

#### âš  criticita' algoritmo âš 
L'algoritmo ha un **problema di instabilitÃ **, alternativamente noto come *problema del conteggio all'infinito*.

Prendiamo un esempio (molto critico) per comprenderlo:
![[Pasted image 20220719224615.png|300]]
- $3$ soli nodi ($x,A,B$) connessi in cascata
- Supponiamo che per qualche motivo si interrompa il collegamento tra $x \longleftrightarrow  A$, ovvero $$x \xcancel{\longleftrightarrow }A$$
- Pertanto, il collegamento assume costo infinito, cioÃ¨ $$ x \stackrel{\large\infty}{\longleftrightarrow} A$$
- Supponiamo che questo evento accada **dopo** che $B$ ha condiviso con $A$ la propria tabella di instradamento che prevede raggiungibilitÃ  di $x$ attraverso $A$ con costo totale di $6$
- La situazione ora Ã¨ la seguente:
	- $A$ ha compreso che la distanza con $x$ Ã¨ $\infty$
	- $B$ non lo sa: non Ã¨ stato informato dell'evento suddetto, quindi ancora non ha inviato ad $A$ la propria tabella aggiornata
- Allora $A$ consulta nuovamente la tabella e scopre che in realtÃ  per quanto c'Ã¨ scritto puÃ² raggiungere $x$ passando da $B$ con costo $10$. Quindi aggiunge la tabella.
- A sua volta $B$ aggiorna la propria tabella sapendo che puÃ² raggiungere $x$ soltanto passando da $A$, quindi a sua volta aggiorna il costo e lo porta a $14$
- Il procedimento continua: $B$ comunica ad $A$ che puÃ² raggiungere $x$ costo $14$. Quindi $A$ aggiorna il costo (dato che il diretto $A\to x$ costa $\infty$) e lo pone a $18$
- A un certo punto entrambi raggiungono un valore di cammino per $x$ molto grande, e quindi comprendono che tale nodo non Ã¨ raggiungibile $\to$ *spreco di tempo ed energie*

> [!success] Soluzioni al problema
> Sono state trovare quindi delle soluzioni a questo problema. In particolare $3$ metodi:
> > [!info] Infinito finito
> > Si stabilisce un valore massimo per il costo del collegamento, superato il quale il collegamento converge alla situazione di "improponibile/impossibile", ovvero equivale trattare costo $\infty$
> > ðŸ˜ƒ: riduce il disservizio, ðŸ˜¡ non lo elimina del tutto (specie se il numero che impostiamo Ã¨ alto)
> 
> > [!note] Split Horizon
> *Orizzonte diviso*: permette di evitare di mandare aggiornamenti in quei percorsi che si sa essere attuati passando dal nodo verso il quale si sta mandando l'aggiornamento.
> >> Nell'esempio proposto, $B$ sa che raggiunge $x$ attraverso $A$ quindi non manda ad $A$ l'aggiornamento del suo percorso verso $x$ (al limite manda gli altri, come $B \to A$) 
> >
> >ðŸ˜¡ A livello di come sono implementati i dispositivi tuttavia, si sa che se un dispositivo (nel nostro caso $A$) non riceve notizie (aggiornamenti) da un altro (ad esempio $B$) per un certo lasso di tempo, allora il primo puÃ² ritenere il secondo come "inattivo", quindi escluderlo dai suoi "vicini". Per questo Ã¨ stato ideato il terzo metodo...
> 
> > [!quote] Metodo Ibrido: Split Horizon with Poison Reverse
> Si mandano aggiornamenti periodici per *tutti* i cammini, anche quelli esposti nel secondo metodo, assegnandoli un valore *alto*, cosÃ¬ che poi non saranno mai effettivamente scelti.
> In questo modo anche i dispositivi "critici" continuano a essere considerati attivi



### LINK STATE (ALGORITMO)
- Converge all'ottimo con una maniera diversa: i nodi in questo caso si "aiutano a vicenda", ma ognuno **non** manda in rete la tabella completa, ma bensÃ¬ unicamente *l'informazioni riguardo i percorsi che puÃ² gestire con i costi relativi* (cioÃ¨ non manda la tabella in blocco ma solo i singoli componenti in modo individuale e solo quando il nodo percepisce cambiamenti rispetto a situazioni precedenti)
	- Quindi non si mandano tutti, e quei singoli si mandano solo in casi di cambiamento (non periodicamente "a dritto")
	- Risolve il problema del conteggio all'infinito ðŸ˜ƒ

Passi:
- Si accende un nodo
- Esso scopre i propri vicini e manda l'informazione a ciascuno riguardo il percorso con il relativo costo
- I vicini lo ricevono, aggiornano la tabella ed eventualmente se ci sono stati effettivamente degli aggiornamenti li comunicano a tutti gli altri
	>Mentre prima l'informazione veniva trasferita solo fino ai nodi direttamente connessi, in questo caso *l'informazione di un cammino che cambia costo arriva a tutti i nodi della rete*. Ãˆ quindi piÃ¹ pervasiva, non Ã¨ cioÃ¨ piÃ¹ limitata a un $hop$
	>> Quindi nel caso precedente l'informazione arrivava solo ai vicini ($hop$). In questo caso invece arriva (influenza) a tutti


Possiamo esporre l'algoritmo come segue:
> Il link state trova i *percorsi a costo minimo* da un nodo sorgente *verso tutti gli altri nodi* definendoli per costi crescenti

![[Pasted image 20220719235939.png|600]]

[vedi esercizio sulle slide](vedi esercizio sulle slide)


> [!note] Vediamo ora una serie di algoritmi che derivano dai precedenti che abbiamo visto
> 

### RIP (ALGORITMO - BASATO SU DISTANCE VECTOR)
- Utilizza come (metrica di) costo dei collegamenti il numero di $hop$ nel percorso sorgente-destinazione
#### CARATTERISTICHE
- Essendo distance vector, puÃ² soffrire di conteggio all'infinito ðŸ˜¡
	- La soluzione proposta Ã¨ quella dell'infinito finito ðŸ˜ƒ
		- Il numero fissato a tal proposito Ã¨ $15$
			- Buono perchÃ© ci si ferma presto, ma se ci fossero collegamenti piÃ¹ distanti di $15$ $hop$?
				- Quindi, l'efficienza dell'algoritmo Ã¨ dipendente al numero di dispositivi ðŸ˜¡

- Per l'aggiornamento delle tabelle, si prevede uno scambio con un rate di $30$ secondi
	- La procedura (che manda un datagramma IP) prende il nome di $\text{RIP} \ advertisement$
	- PuÃ² essere inviata a massimo $25$ destinazioni ðŸ˜¡
	- Se un nodo non manda niente per $180s$ viene considerato inattivo e quindi escluso dalla rete ðŸ˜’
	- Esistono anche messaggi specifici per aggiornare l'algoritmo

- I messaggi contenenti l'istruzioni di routing (aggiornamenti e non solo), che sono ovviamente "molto delicati", vengono inviati tuttavia con protocollo UDP (e non TCP) ðŸ˜®
	- Oltre al tipo di protocollo utilizzato, ci chiediamo soprattutto: dato che il router lavora a livello $3$, perchÃ© dobbiamo utilizzare un protocolli di livello superiore ($4$) per il trasferimento invece che il protocollo IP?
		- Questo perchÃ© in realtÃ  *questi algoritmi sono applicazioni* che risiedono nel relativo piano applicazioni appunto, e quindi comandano lo stato TCP che Ã¨ a livello inferiore.


### OSPF - BASATO SU LINK STATE
$Open \ Shortest \ Path \ First$ (scegliere prima il percorso piÃ¹ corto)
- Usa l'algoritmo di $Dijkstra$

- Il costo non Ã¨ un valore univoco - Ã¨ specifico della relativa rete di riferimento

#### CARATTERISTICHE
- Gli aggiornamenti avvengono in modalitÃ  $flooding$: i nodi mandano gli aggiornamenti dei cammini ai vicini $\to$ puÃ² succedere che un nodo possa ricevere messaggi di aggiornamento da uno stesso nodo generati in momenti diversi. Il nodo deve tener conto solo dell'ultimo di essi (che Ã¨ quello piÃ¹ aggiornato).
	- Per questo, in ogni messaggio c'Ã¨ un $time \text{-} stamp$ che viene associato.
	- Ogni nodo che riceve un aggiornamento quindi controlla se nel proprio DB ha una copia piÃ¹ recente dello stesso aggiornamento. In caso affermativo, esclude il messaggio e lo rimanda indietro, con allegato il $time \text{-} stamp$ dell'aggiornamento piÃ¹ recente che possiede. Altrimenti si considera il messaggio e si aggiorna il DB
	- Se non avvengono aggiornamenti, ogni $30$ minuti il router procede a diffondere un messaggio di default con lo stato dei dispositivi 

- Quando un nodo viene accesso per la prima volta si presenta ai propri vicini con un messaggio di $\text{HELLO}$

- Prevede di autenticare la fonte che fornisce le informazioni di aggiornamento $\to$ livello di *sicurezza alto* dell'algoritmi

- Permette l'utilizzo dei percorsi che hanno lo stesso costo in modo indistinto

- Permette di utilizzare modalitÃ  di *instradamento diverse* da quelle previste da una certa sorgente-destinazione
	- In dettaglio, tra le altre:
		- Prevede il *multicast*: invio di un pacchetto da una sorgente a piÃ¹ destinazioni; 
		- Prevede il *broadcast*: invio di un pacchetti da una sorgente a tutti gli altri nodi della rete

- ogni nodo lavora in modo indipendente costruendosi la sua tabella (in questo modo se qualcuno sbaglia, l'errore non si propaga nella rete)

---
*[algoritmi gerarchici: non li facciamo]*

---

## NUOVA (MODERNA) TECNICA DI INSRADAMENTO: MPLS
$Multi \ Protocol \ Label \ Switch$
- Tecnica di instradamento (switching) multiprotocolli basata su $label$ (etichette)

- Si impegna a migliorare le tecniche preesistenti:
	- ðŸ”: alta velocitÃ  di trasferimento di switching/router (un po' come introdurre il telepass in autostrada: si ha una velocitÃ  di percorrenza ai caselli piÃ¹ veloce)

- Ha migliorato le precedenti reti $x25$ e $\text{ATM}$, con la differenza che stavolta si lavora a livello di $etichetta$ invece che di indirizzo:
	- PiÃ¹ indirizzi possono essere associati a una stessa etichetta: questo alleggerisce le operazioni di routing, perchÃ© scoprendo/elaborando un' unica etichetta si gestiscono piÃ¹ indirizzi rendendo quindi piÃ¹ veloci le operazioni
		- (associo piÃ¹ flussi informativi a una stessa etichetta)

- Permette di *poter differenziare le rotte in relazione ai requisiti di servizio a cui il flusso informativo Ã¨ associato* - questo permette di associare a etichette diverse anche flussi destinati a una stessa destinazione
	- In questo modo ==etichette diverse $\longleftrightarrow$ gestioni diverse inoltro messaggio in rete==
	- Si vÃ¬ola da un certo punto di vista il senso d'instradamento classico che abbiamo, in cui si associa in maniera *biunivoca* la sorgente dalla destinazione (questo non avviene piÃ¹)
		- Gli algoritmi precedenti associano un unico percorso a una destinazione, trovando un percorso ottimo
		- ==Stavolta una stessa destinazione puÃ² essere raggiunta da una sorgente *con percorsi diversi* a seconda del tipo di traffico che viene mandato==
			- Apre le discussioni alla $Traffic \ Engineering$

- E' un $middleware$, livello intermedio tra il livello collegamento e il livello IP

- ModalitÃ  a commutazione di circuito (CC)

#### COMPOSIZIONE
Il campo MPLS comprende $4$ byte, ed Ã¨ cosÃ¬ composto:
![[Pasted image 20220720001847.png|400]]
- Label: vedi sopra
- EXP: Sperimentale (quasi mai usato)
- S: flag che indica se c'Ã¨ una o piÃ¹ etichette scritte nel campo $label$
- TTL: Time To Live

> Dove si mette questo campo di $32$ bit?
> 	Deve *precedere la testa IP*, quindi va inserita nel campo di informazione di livello $2$
> 		Va letta *prima* della testata IP per capire se si puÃ² ridurre i tempi

---

## ROUTING MULTICAST E BROADCAST
Fin ora abbiamo considerato solo casi di *routing unicast*, ovvero collegamenti tra una sorgente e una destinazione, del tipo 
$$
1:1
$$
![[Pasted image 20220720105412.png|300]]

Studiamo ora le modalitÃ  *multicast* (uno a molti) e *broadcast* (uno a tutti): 
$$
1:n  \quad , \quad 1:N \quad \quad \quad 1<n<N \in \mathbb{N}
$$
> Si Ã¨ pensato a queste nuove modalitÃ  per rispondere a servizi specifici soprattutto a livello applicazione - ad esempio $e \text{-} learning$ (multicast - un host che trasmette a tanti)

![[Pasted image 20220720105436.png|400]]
- si nota come in questa modalitÃ  *ogni router effettua tante copie del pacchetto quante sono le porte*, e le inoltra in tutte queste

L'alternativa si chiama *multi-unicast*: nelle ipotesi di conoscere quante sono le destinazioni da raggiungere, il nodo sorgente inoltra altrettante copie del pacchetto, e i vari router ne trattengono una e smistano le rimanenti agli altri
- ðŸ˜ƒ: piuttosto sicuro
- ðŸ˜¡: molto pesante da implementare - quasi mai usato


### TECNICHE DI ROUTING BROADCAST
Ci chiediamo in che modo si puÃ² mandare un pacchetto a tutti gli utenti della rete:
1) *Flooding Broadcast* (giÃ  visto): ogni nodo che riceve un pacchetto broadcast lo inoltra su tutte le porte tranne quella da cui Ã¨ arrivato
ðŸ˜ƒ: semplice
ðŸ˜¡: possibile inondazione ðŸ˜ƒsi risolve o comunque si limita impostando $\text{TTL}=1$
ðŸ˜¡: inefficiente e talvolta pesante


2) *Reverse Path Forwarding*: si ripete a molti (multicast) & *Reverse Path Broadcast*** (si ripete a tutti)
- Percorso inverso: ogni nodo, che ha la propria tabella di routing, quando riceve un pacchetto controlla se la porta da cui Ã¨ arrivato Ã¨ la porta che corrisponde al cammino (inverso) piÃ¹ breve che lo connette con quella sorgente
	- In caso affermativo, processa il pacchetto
	- Altrimenti no, non fa niente - vuol dire che esiste un percorso migliore
 

![[Pasted image 20220720110954.png|250]]
- Esempio: a $C$ gli arriva un pacchetto da $A$; poco dopo gli arriva lo stesso che Ã¨ passato da $B$, ovvero: $A\to B\to C$. Il nodo $C$ processa quindi solo quello che gli Ã¨ arrivato da $A$

#### MODALITA'
Esistono due modalitÃ  per attuare tale procedura:
- si elegge un coordinatore del gruppo multicast (o broadcast), ad esempio il nodo $A$. In questo modo, quando un $nodo \neq A$ vuole mandare un pacchetto a tutti non lo manda direttamente, ma lo manda ad $A$ attraverso il collegamento migliore (che risiede nella propria tabella).
	- A questo punto $A$ lo inoltra con modalitÃ  Reverse Path Forwarding (Broadcast)

In alternativa, il nodo sorgente (in questo caso $A$) puÃ² costruire innanzitutto il proprio albero di collegamenti multicast (o broadcast), in questo modo quando arriva una richiesta sa giÃ  dove smistarla e come
![[Pasted image 20220720111833.png|400]]

##### Come avviene l'adesione di un nodo a un albero?
Un nodo invia la propria richiesta di appartenere all'albero (multicast per esempio) all'amministratore (nel nostro caso $A$) $\to$ procedura detta innesto
- La richiesta $nodo \to A$ deve attraversare tutto l'albero quindi comporta *ritardo*
	- Allora per velocizzare, la richiesta di adesione *si ferma al primo nodo che appartiene al gruppo multicast* - esso Ã¨ giÃ  connesso al coordinatore $A$, quindi si impegnerÃ  lui a gestire la richiesta
		- Vale lo stesso per la fase di $\textcolor{red}{dissociazione}$, e prende il nome di *potatura*


