# ALGORITMI DI ROUTING

### ROUTING
- Instradamento 
Permette di mettere in comunicazione una sorgente con una destinazione - individuando i percorsi pi√π tra tutte le alternative

Effettuata da un Router

### ATTIVITA' DI UN ROUTER
Due step:

1) Ricerca destinazione: interpretare l'indirizzo a cui si deve inoltrare il pacchetto (e quindi individuare la porta di uscita)
2) Inoltro (forwarding) $\to$ trasmissione effettiva dei bit nella uscita selezionata

## ALGORITMI DI ROUTING
Si cercano metodi/algoritmi che siano:
 - semplici da realizzare
 - robusti (affidabili)
 - stabili
 - ottimi (secondo alcuni criteri)

Le tecniche di routing si possono dividere nel seguente modo:
- Implementazione caratteristica
	- Tipologia algoritmo
		- Ulteriori tipologie
![[Pasted image 20220719193146.png|500]]
**- Senza Tabella** $\to$ senza interrogazione del database locale
	- Random
	- Flooding
	- Source Routing
- **Gerarchico** (cfr. rete telefonica)
**- Con Tabella** $\to$ il router ha un database dove sono contenute le info utili per il routing
	- Dinamico
		- Distance Vector
		- Link State
	- Statico (stesse organizzazioni)


Sistema:
- **Centralizzato**: esiste un dispositivo (anche cloud) che sceglie quale algoritmo usare e collabora con i vari dispositivi
- **Distribuito**: pi√π elementi che gestiscono il routing che cooperano per definire le strategie di routing migliori
- **Isolata**: un router in maniera individuale decide cosa fare (decisioni da prendere tipo algoritmo di routing)

---
## SENZA TABELLA

### ALGORITMO RANDOM
Si selezione su base  random su quale porta disponibile nel router andare a ripetere il messaggio ricevuto (escludendo quella da cui il messaggio √® arrivato)
![[Pasted image 20220719195806.png|400]]
- E' robusto perch√© se si guasta qualche link basta toglierlo dalle possibili scelte, ma l'algoritmo funziona lo stesso üòÉ
- Non √® ottimo perch√© la scelta √® quasi randomica quindi non sar√† facile statisticamente trovare quella ottima üò°
- Semplice da realizzare üòÉ
- Senza tabella: l'azione viene eseguita senza passare dalla consultazione di un database locale (quindi anche veloce) üòÉ

### FLOODING
Si ripete un messaggio su tutte le porte di uscita (escludendo quella da cui arriva)
- Semplice (il pi√π semplice di tutti) üòÉ
- Rischio di inondazione $\to$ allora si imposta un TTL per limitare (cfr. appunti precedenti) üò°
- Sicuro üòÉ
	- Utilizzato per questo dove si vuol privilegiare la sicurezza che un messaggio arrivi a destinazione rispetto che la velocit√†/prestazione
		- Ad esempio nelle reti militari (poco estese e necessariamente sicure)

### SOURCE ROUTING
Metodo che pu√≤ essere implementato con due modalit√†:
- Centralizzata ($path \ server$): ogni nodo che ha bisogno di inviare un messaggio verso una certa destinazione pone la richiesta al "cloud" ($sink$/apparato centrale). Quest'ultimo ha gi√† costruito tutte le possibili rotte che pu√≤ gestire e trasferisce al nodo le migliori informazioni per gestire il routing
- Isolata ($path \ discovery$): direttamente il nodo interessato capisce qual √® la rotta da seguire - questo gli √® permesso effettuando prima il $discovery$ (scoperta) mandando un *pacchetto esploratore* che viene inoltrato nella rete con modalit√† $floating$ con $\text{TTL}=1$ (massimo una ripetizione) $\to$ si scopre il path migliore
	- Viaggiano molte copie del pacchetto esploratore sulla rete: una di queste arriver√† alla destinazione cercata
	- Ogni volta che il pacchetto visita un nodo viene scritto sull'$header$ il nome del pacchetto ch ha visitato
	- Quando il pacchetto arriva alla destinazione c'√® la "cronologia dei nodi", quindi baster√† ripercorrerla in maniera opposta per scoprire ufficialmente anche dal punto di vista del nodo sorgente il percorso migliore
		- Si considera come rotta migliore quella che arriva prima


---
## ALGORITMI CON TABELLA
Un nodo quando riceve un pacchetto se lo salva/copia nel proprio database locale, dopo aver controllato che in esso non fosse gi√† presente (abbinamenti indirizzo sorgete indirizzo destinazione)
- Pi√π efficiente üòÉ ‚úÖ
- Pi√π impegnativo (quindi anche pi√π lento) üò°

I due algoritmi che mostreremo sono molto simili tra loro:
- Entrambi arrivano (in modo diverso) alla soluzione ottima
- La differenza principale riguarda la modalit√† attuativa di realizzare la cooperazione tra i nodi

### DISTANCE VECTOR
- Ogni nodo si interfaccia (coopera) con i nodi direttamente connessi (detti "nodi vicini") su base $link \text{-} to \text{-} link$.
	- Ogni nodo trasferisce la propria tabella di routing (condividendola) con i propri vicini

Nella tabella di routing c'√® un campo $next \text{-} hop$: ovvero il router del passaggio successivo a cui inviare il pacchetto (affinch√© poi arrivi alla destinazione finale)
	Non c'√® scritto tutto il percorso, c'√® solo il router vicino
		(nota: se non ci sono vicini si sceglie un router di default)

L'algoritmo pu√≤ essere enunciato in questo modo:
> Trovare percorsi a costo minimo partendo da un nodo sorgente e selezionando i successivi progressivamente 

##### COSTO
Valore di riferimento assegnato a un collegamento con l'obiettivo di costruire un percorso sorgente-destinazione che abbia tale valore minore (costo minore)
- Pu√≤ essere legato al tempo, al numero totale di nodi, all'affidabilit√† etc...
	- L'importante √® stabilirne uno per individuare l'alternativa migliore in un certo contesto

Ad esempio:
- Per fare $\text{A}\to B$ conviene il collegamento diretto
- Per fare $\text{A} \to \text{C}$ non conviene il collegamento diretto ma conviene fare $\text{A} \to \text{B} \to \text{C}$
![[Pasted image 20220719222410.png|250]]

#### ESECUZIONE
Vediamo l'esecuzione dell'algoritmo con un esempio
- Sono noti i costi dei links
![[Pasted image 20220719223503.png|350]]
Passaggi:
- Si sceglie un nodo di partenza, ad esempio $\text{A}$
- Si prende il nodo connesso al nodo di partenza con costo minore, e lo si considera parte di $\text{A}$. In altre parole, in questo caso: $\text{A} \longleftarrow \text{C}$
	- Si ripete lo stesso per ogni nodo, e si condividono le tabelle
- Quando $\text{C}$ condivide la sua tabella con $\text{A}$, quest'ultimo acquisisce una visione che prima non aveva (pi√π profonda). In questo modo comincia a verificare se passando da $\text{C}$ riesce a migliorare alcuni path verso altri nodi (in termini di costo)
	- In questo caso ad esempio $\text{A}$ scopre che pu√≤ raggiungere $\text{E}$ con un costo totale di $6$, che probabilmente sar√† un costo minimo (ancora per√≤ deve verificare tutti i percorsi per la conferma - per√≤ intanto segna sulla tabella)
- Si continuano a scambiare tabelle finch√© queste non subiscono pi√π cambiamenti, ovvero si arriva a una *soluzione stabile*

![[Pasted image 20220719223520.png|500]]

##### ESEMPIO DI AGGIORNAMENTO DI UNA TABELLA
Vediamo la procedura effettiva di scambio (condivisione) delle tabelle:
- Sappiamo che ogni $tot$ i nodi si scambiano le tabelle 
- Nel seguente caso, $\text{C}$ manda ad $\text{A}$ l'aggiornamento della propria tabella
- Ora, $\text{A}$ deve aggiornare questi valori sommando a tutti costi di raggiungimento relativi $C\to \text{?}$ (ovvero a tutte le righe della tabella) i costi di  $\text{A} \to \text{C}$.
	- In questo caso si somma $2$ essendo $\text{A} \to \text{C}=2$
- Viene quindi comparata la nuova tabella di $\text{A}$ con quella vecchia e se ne crea una "ibrida" composta dai valori migliori relativi a ciascuna riga
	- In questo caso si ha un miglioramento solo nella ultima e quinta riga, che permette ad $\text{A}$ di raggiungere $\text{E}$ (che prima era irraggiungibile, ovvero con costo $\infty$) con un costo $6$
![[Pasted image 20220719224257.png|400]]

Proseguendo con questo su tutti i nodi si ottiene un $albero$ (dei costi minimi)

#### ‚ö† criticita' algoritmo ‚ö†
L'algoritmo ha un **problema di instabilit√†**, alternativamente noto come *problema del conteggio all'infinito*.

Prendiamo un esempio (molto critico) per comprenderlo:
![[Pasted image 20220719224615.png|300]]
- $3$ soli nodi ($x,A,B$) connessi in cascata
- Supponiamo che per qualche motivo si interrompa il collegamento tra $x \longleftrightarrow  A$, ovvero $$x \xcancel{\longleftrightarrow }A$$
- Pertanto, il collegamento assume costo infinito, cio√® $$ x \stackrel{\large\infty}{\longleftrightarrow} A$$
- Supponiamo che questo evento accada **dopo** che $B$ ha condiviso con $A$ la propria tabella di instradamento che prevede raggiungibilit√† di $x$ attraverso $A$ con costo totale di $6$
- La situazione ora √® la seguente:
	- $A$ ha compreso che la distanza con $x$ √® $\infty$
	- $B$ non lo sa: non √® stato informato dell'evento suddetto, quindi ancora non ha inviato ad $A$ la propria tabella aggiornata
- Allora $A$ consulta nuovamente la tabella e scopre che in realt√† per quanto c'√® scritto pu√≤ raggiungere $x$ passando da $B$ con costo $10$. Quindi aggiunge la tabella.
- A sua volta $B$ aggiorna la propria tabella sapendo che pu√≤ raggiungere $x$ soltanto passando da $A$, quindi a sua volta aggiorna il costo e lo porta a $14$
- Il procedimento continua: $B$ comunica ad $A$ che pu√≤ raggiungere $x$ costo $14$. Quindi $A$ aggiorna il costo (dato che il diretto $A\to x$ costa $\infty$) e lo pone a $18$
- A un certo punto entrambi raggiungono un valore di cammino per $x$ molto grande, e quindi comprendono che tale nodo non √® raggiungibile $\to$ *spreco di tempo ed energie*

> [!success] Soluzioni al problema
> Sono state trovare quindi delle soluzioni a questo problema. In particolare $3$ metodi:
> > [!info] Infinito finito
> > Si stabilisce un valore massimo per il costo del collegamento, superato il quale il collegamento converge alla situazione di "improponibile/impossibile", ovvero equivale trattare costo $\infty$
> > üòÉ: riduce il disservizio, üò° non lo elimina del tutto (specie se il numero che impostiamo √® alto)
> 
> > [!note] Split Horizon
> *Orizzonte diviso*: permette di evitare di mandare aggiornamenti in quei percorsi che si sa essere attuati passando dal nodo verso il quale si sta mandando l'aggiornamento.
> >> Nell'esempio proposto, $B$ sa che raggiunge $x$ attraverso $A$ quindi non manda ad $A$ l'aggiornamento del suo percorso verso $x$ (al limite manda gli altri, come $B \to A$) 
> >
> >üò° A livello di come sono implementati i dispositivi tuttavia, si sa che se un dispositivo (nel nostro caso $A$) non riceve notizie (aggiornamenti) da un altro (ad esempio $B$) per un certo lasso di tempo, allora il primo pu√≤ ritenere il secondo come "inattivo", quindi escluderlo dai suoi "vicini". Per questo √® stato ideato il terzo metodo...
> 
> > [!quote] Metodo Ibrido: Split Horizon with Poison Reverse
> Si mandano aggiornamenti periodici per *tutti* i cammini, anche quelli esposti nel secondo metodo, assegnandoli un valore *alto*, cos√¨ che poi non saranno mai effettivamente scelti.
> In questo modo anche i dispositivi "critici" continuano a essere considerati attivi



### LINK STATE (ALGORITMO)
- Converge all'ottimo con una maniera diversa: i nodi in questo caso si "aiutano a vicenda", ma ognuno **non** manda in rete la tabella completa, ma bens√¨ unicamente *l'informazioni riguardo i percorsi che pu√≤ gestire con i costi relativi* (cio√® non manda la tabella in blocco ma solo i singoli componenti in modo individuale e solo quando il nodo percepisce cambiamenti rispetto a situazioni precedenti)
	- Quindi non si mandano tutti, e quei singoli si mandano solo in casi di cambiamento (non periodicamente "a dritto")
	- Risolve il problema del conteggio all'infinito üòÉ

Passi:
- Si accende un nodo
- Esso scopre i propri vicini e manda l'informazione a ciascuno riguardo il percorso con il relativo costo
- I vicini lo ricevono, aggiornano la tabella ed eventualmente se ci sono stati effettivamente degli aggiornamenti li comunicano a tutti gli altri
	>Mentre prima l'informazione veniva trasferita solo fino ai nodi direttamente connessi, in questo caso *l'informazione di un cammino che cambia costo arriva a tutti i nodi della rete*. √à quindi pi√π pervasiva, non √® cio√® pi√π limitata a un $hop$
	>> Quindi nel caso precedente l'informazione arrivava solo ai vicini ($hop$). In questo caso invece arriva (influenza) a tutti


Possiamo esporre l'algoritmo come segue:
> Il link state trova i *percorsi a costo minimo* da un nodo sorgente *verso tutti gli altri nodi* definendoli per costi crescenti

![[Pasted image 20220719235939.png|600]]

[vedi esercizio sulle slide](vedi esercizio sulle slide)


> [!note] Vediamo ora una serie di algoritmi che derivano dai precedenti che abbiamo visto
> 

### RIP (ALGORITMO - BASATO SU DISTANCE VECTOR)
- Utilizza come (metrica di) costo dei collegamenti il numero di $hop$ nel percorso sorgente-destinazione
#### CARATTERISTICHE
- Essendo distance vector, pu√≤ soffrire di conteggio all'infinito üò°
	- La soluzione proposta √® quella dell'infinito finito üòÉ
		- Il numero fissato a tal proposito √® $15$
			- Buono perch√© ci si ferma presto, ma se ci fossero collegamenti pi√π distanti di $15$ $hop$?
				- Quindi, l'efficienza dell'algoritmo √® dipendente al numero di dispositivi üò°

- Per l'aggiornamento delle tabelle, si prevede uno scambio con un rate di $30$ secondi
	- La procedura (che manda un datagramma IP) prende il nome di $\text{RIP} \ advertisement$
	- Pu√≤ essere inviata a massimo $25$ destinazioni üò°
	- Se un nodo non manda niente per $180s$ viene considerato inattivo e quindi escluso dalla rete üòí
	- Esistono anche messaggi specifici per aggiornare l'algoritmo

- I messaggi contenenti l'istruzioni di routing (aggiornamenti e non solo), che sono ovviamente "molto delicati", vengono inviati tuttavia con protocollo UDP (e non TCP) üòÆ
	- Oltre al tipo di protocollo utilizzato, ci chiediamo soprattutto: dato che il router lavora a livello $3$, perch√© dobbiamo utilizzare un protocolli di livello superiore ($4$) per il trasferimento invece che il protocollo IP?
		- Questo perch√© in realt√† *questi algoritmi sono applicazioni* che risiedono nel relativo piano applicazioni appunto, e quindi comandano lo stato TCP che √® a livello inferiore.


### OSPF - BASATO SU LINK STATE
$Open \ Shortest \ Path \ First$ (scegliere prima il percorso pi√π corto)
- Usa l'algoritmo di $Dijkstra$

- Il costo non √® un valore univoco - √® specifico della relativa rete di riferimento

#### CARATTERISTICHE
- Gli aggiornamenti avvengono in modalit√† $flooding$: i nodi mandano gli aggiornamenti dei cammini ai vicini $\to$ pu√≤ succedere che un nodo possa ricevere messaggi di aggiornamento da uno stesso nodo generati in momenti diversi. Il nodo deve tener conto solo dell'ultimo di essi (che √® quello pi√π aggiornato).
	- Per questo, in ogni messaggio c'√® un $time \text{-} stamp$ che viene associato.
	- Ogni nodo che riceve un aggiornamento quindi controlla se nel proprio DB ha una copia pi√π recente dello stesso aggiornamento. In caso affermativo, esclude il messaggio e lo rimanda indietro, con allegato il $time \text{-} stamp$ dell'aggiornamento pi√π recente che possiede. Altrimenti si considera il messaggio e si aggiorna il DB
	- Se non avvengono aggiornamenti, ogni $30$ minuti il router procede a diffondere un messaggio di default con lo stato dei dispositivi 

- Quando un nodo viene accesso per la prima volta si presenta ai propri vicini con un messaggio di $\text{HELLO}$

- Prevede di autenticare la fonte che fornisce le informazioni di aggiornamento $\to$ livello di *sicurezza alto* dell'algoritmi

- Permette l'utilizzo dei percorsi che hanno lo stesso costo in modo indistinto

- Permette di utilizzare modalit√† di *instradamento diverse* da quelle previste da una certa sorgente-destinazione
	- In dettaglio, tra le altre:
		- Prevede il *multicast*: invio di un pacchetto da una sorgente a pi√π destinazioni; 
		- Prevede il *broadcast*: invio di un pacchetti da una sorgente a tutti gli altri nodi della rete

- ogni nodo lavora in modo indipendente costruendosi la sua tabella (in questo modo se qualcuno sbaglia, l'errore non si propaga nella rete)

---
*[algoritmi gerarchici: non li facciamo]*

---

## NUOVA (MODERNA) TECNICA DI INSRADAMENTO: MPLS
$Multi \ Protocol \ Label \ Switch$
- Tecnica di instradamento (switching) multiprotocolli basata su $label$ (etichette)

- Si impegna a migliorare le tecniche preesistenti:
	- üîù: alta velocit√† di trasferimento di switching/router (un po' come introdurre il telepass in autostrada: si ha una velocit√† di percorrenza ai caselli pi√π veloce)

- Ha migliorato le reti $x25$ e $\text{ATM}$, con la differenza che stavolta si lavora a livello di $etichetta$ invece che di indirizzo:
	- Pi√π indirizzi possono essere associati a una stessa etichetta: questo alleggerisce le operazioni di routing, perch√© scoprendo/elaborando un' unica etichetta si gestiscono pi√π indirizzi rendendo quindi pi√π veloci le operazioni
		- (associo pi√π flussi informativi a una stessa etichetta)

- Permette di *poter differenziare le rotte in relazione ai requisiti di servizio a cui il flusso informativo √® associato* - questo permette di associare a etichette diverse anche flussi destinati a una stessa destinazione
	- In questo modo ==etichette diverse $\longleftrightarrow$ gestioni diverse inoltro messaggio in rete==
	- Si v√¨ola da un certo punto di vista il senso d'instradamento classico che abbiamo, in cui si associa in maniera *biunivoca* la sorgente dalla destinazione (questo non avviene pi√π)
		- Gli algoritmi precedenti associano un unico percorso a una destinazione, trovando un percorso ottimo
		- ==Stavolta una stessa destinazione pu√≤ essere raggiunta da una sorgente *con percorsi diversi* a seconda del tipo di traffico che viene mandato==
			- Apre le discussioni alla $Traffic \ Engineering$

- Modalit√† a commutazione di circuito (CC)

#### COMPOSIZIONE
Il campo MPLS comprende $4$ byte, ed √® cos√¨ composto:
![[Pasted image 20220720001847.png|400]]
- Label: vedi sopra
- EXP: Sperimentale (quasi mai usato)
- S: flag che indica se c'√® una o pi√π etichette scritte nel campo $label$
- TTL: Time To Live

> Dove si mette questo campo di $32$ bit?
> 	Deve *precedere la testa IP*, quindi va inserita nel campo di informazione di livello $2$
> 		Va letta *prima* della testata IP per capire se si pu√≤ ridurre i tempi

---

Fin ora abbiamo considerato solo casi di *routing unicast*, ovvero collegamenti tra una sorgente e una destinazione, del tipo $$1:1$$
Studiamo ora le modalit√† *multicast* (uno a molti) e *broadcast* (uno a tutti): $$1:n  \quad , \quad 1:N \quad \quad \quad 1<n<N \in \mathbb{N}$$

1:26