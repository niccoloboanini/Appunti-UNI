# ALGORITMI DI ROUTING

### ROUTING
- Instradamento 
Permette di mettere in comunicazione una sorgente con una destinazione - individuando i percorsi piÃ¹ tra tutte le alternative

Effettuata da un Router

### ATTIVITA' DI UN ROUTER
Due step:

1) Ricerca destinazione: interpretare l'indirizzo a cui si deve inoltrare il pacchetto (e quindi individuare la porta di uscita)
2) Inoltro (forwarding) $\to$ trasmissione effettiva dei bit nella uscita selezionata

## ALGORITMI DI ROUTING
Si cercano metodi/algoritmi che siano:
 - semplici da realizzare
 - robusti (affidabili)
 - stabili
 - ottimi (secondo alcuni criteri)

Le tecniche di routing si possono dividere nel seguente modo:
- Implementazione caratteristica
	- Tipologia algoritmo
		- Ulteriori tipologie
![[Pasted image 20220719193146.png|500]]
**- Senza Tabella** $\to$ senza interrogazione del database locale
	- Random
	- Flooding
	- Source Routing
- **Gerarchico** (cfr. rete telefonica)
**- Con Tabella** $\to$ il router ha un database dove sono contenute le info utili per il routing
	- Dinamico
		- Distance Vector
		- Link State
	- Statico (stesse organizzazioni)


Sistema:
- **Centralizzato**: esiste un dispositivo (anche cloud) che sceglie quale algoritmo usare e collabora con i vari dispositivi
- **Distribuito**: piÃ¹ elementi che gestiscono il routing che cooperano per definire le strategie di routing migliori
- **Isolata**: un router in maniera individuale decide cosa fare (decisioni da prendere tipo algoritmo di routing)

---
## SENZA TABELLA

### ALGORITMO RANDOM
Si selezione su base  random su quale porta disponibile nel router andare a ripetere il messaggio ricevuto (escludendo quella da cui il messaggio Ã¨ arrivato)
![[Pasted image 20220719195806.png|400]]
- E' robusto perchÃ© se si guasta qualche link basta toglierlo dalle possibili scelte, ma l'algoritmo funziona lo stesso ðŸ˜ƒ
- Non Ã¨ ottimo perchÃ© la scelta Ã¨ quasi randomica quindi non sarÃ  facile statisticamente trovare quella ottima ðŸ˜¡
- Semplice da realizzare ðŸ˜ƒ
- Senza tabella: l'azione viene eseguita senza passare dalla consultazione di un database locale (quindi anche veloce) ðŸ˜ƒ

### FLOODING
Si ripete un messaggio su tutte le porte di uscita (escludendo quella da cui arriva)
- Semplice (il piÃ¹ semplice di tutti) ðŸ˜ƒ
- Rischio di inondazione $\to$ allora si imposta un TTL per limitare (cfr. appunti precedenti) ðŸ˜¡
- Sicuro ðŸ˜ƒ
	- Utilizzato per questo dove si vuol privilegiare la sicurezza che un messaggio arrivi a destinazione rispetto che la velocitÃ /prestazione
		- Ad esempio nelle reti militari (poco estese e necessariamente sicure)

### SOURCE ROUTING
Metodo che puÃ² essere implementato con due modalitÃ :
- Centralizzata ($path \ server$): ogni nodo che ha bisogno di inviare un messaggio verso una certa destinazione pone la richiesta al "cloud" ($sink$/apparato centrale). Quest'ultimo ha giÃ  costruito tutte le possibili rotte che puÃ² gestire e trasferisce al nodo le migliori informazioni per gestire il routing
- Isolata ($path \ discovery$): direttamente il nodo interessato capisce qual Ã¨ la rotta da seguire - questo gli Ã¨ permesso effettuando prima il $discovery$ (scoperta) mandando un *pacchetto esploratore* che viene inoltrato nella rete con modalitÃ  $floating$ con $\text{TTL}=1$ (massimo una ripetizione) $\to$ si scopre il path migliore
	- Viaggiano molte copie del pacchetto esploratore sulla rete: una di queste arriverÃ  alla destinazione cercata
	- Ogni volta che il pacchetto visita un nodo viene scritto sull'$header$ il nome del pacchetto ch ha visitato
	- Quando il pacchetto arriva alla destinazione c'Ã¨ la "cronologia dei nodi", quindi basterÃ  ripercorrerla in maniera opposta per scoprire ufficialmente anche dal punto di vista del nodo sorgente il percorso migliore
		- Si considera come rotta migliore quella che arriva prima


---
## ALGORITMI CON TABELLA
Un nodo quando riceve un pacchetto se lo salva/copia nel proprio database locale, dopo aver controllato che in esso non fosse giÃ  presente (abbinamenti indirizzo sorgete indirizzo destinazione)
- PiÃ¹ efficiente ðŸ˜ƒ âœ…
- PiÃ¹ impegnativo (quindi anche piÃ¹ lento) ðŸ˜¡

I due algoritmi che mostreremo sono molto simili tra loro:
- Entrambi arrivano (in modo diverso) alla soluzione ottima
- La differenza principale riguarda la modalitÃ  attuativa di realizzare la cooperazione tra i nodi

### DISTANCE VECTOR
- Ogni nodo si interfaccia (coopera) con i nodi direttamente connessi (detti "nodi vicini") su base $link \text{-} to \text{-} link$.
	- Ogni nodo trasferisce la propria tabella di routing (condividendola) con i propri vicini

Nella tabella di routing c'Ã¨ un campo $next \text{-} hop$: ovvero il router del passaggio successivo a cui inviare il pacchetto (affinchÃ© poi arrivi alla destinazione finale)
	Non c'Ã¨ scritto tutto il percorso, solo a chi dei vicini bisogna mandare il pacchetto
		(nota: se non ci sono vicini si sceglie un router di default)

L'algoritmo puÃ² essere enunciato in questo modo:
> Trovare percorsi a costo minimo partendo da un nodo sorgente e selezionando i successivi progressivamente 








