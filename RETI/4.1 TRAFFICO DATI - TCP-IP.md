## PROTOCOLLO TCP-IP
- Detto anche modello $internet$
- Architettura a livelli basata su quanto visto nel caso $\text{ISO-OSI}$ (seppur semplificata)

![[Pasted image 20220713152654.png|250]]

### PANORAMICA DEI LIVELLI
#### 1) HOST TO NETWORK
Definito in maniera generica perchÃ© adattabile a piÃ¹ contesti
- Permette la possibilitÃ  di usufruire del protocollo TCP-IP anche tra reti eterogenee, cioÃ¨ tra reti che hanno livello collegamento e fisico diversi (cosÃ¬ che il protocollo diventa adattabile a piÃ¹ contesti)

#### 2) INTERNET
Livello rete (IP): permette di configurare la rete in modo tale da consentire lo scambio di pacchetti tra nodi della rete
- Si preoccupa dell'*instradamento*, cioÃ¨ la modalitÃ  con cui l'informazione viene gestita nella rete circa i percorsi che deve fare (di default Ã¨ a datagramma, quindi $connectionless$, sarÃ  poi eventualmente il livello trasporto a implementare tecniche di $connection \ oriented$)
> Riassumendo: Gestisce lo scambio di pacchetti tra coppie sorgente-destinazione in modalitÃ  $connectionless$ non affidabile (no controllo integritÃ ). E' attivato in modalitÃ  link-to-link (tutti i nodi della rete hanno libello rete)

#### 3) TRASPORTO
Detto anche TCP: definisce e attua le modalitÃ  di scambio di pacchetti ($connection \ oriented$, $connectionless$...) - come nell'ISO-OSI
- I pacchetti scambiati/generati a questo livello sono detti $datagram$
- Ãˆ attivato su base end-to-end (implementa quindi eventualmente il controllo integritÃ )
	- Quindi rende possibili entrambe le modalitÃ  $connection \ oriented$ e $connectionless$
- Controlla talvolta (e implementa) il controllo dell'integritÃ  della informazione ricevuta

#### 4) APPLICAZIONE
Analogo al caso ISO-OSI

> [!abstract] Livelli Mancanti rispetto a ISO-OSI (sessione, presentazione). PerchÃ©?
> Primo motivo: Ã¨ nata prima dell'ISO-OSI
> Era storicamente pensata per un unico fornitore (quindi ad esempio non serviva il livello presentazione perchÃ© il formato si supponeva univoco)
> 

---
### ESEMPIO DI COLLEGAMENTO
![[Pasted image 20220713154610.png|400]]

*A vuole connettersi a D*
A apre il collegamento (magari a livello applicazione) e inizia il viaggio dei pacchetti:
- Dal livello rete di A si scende fino al livello fisico passando dal livello collegamento, e si invia tramite il mezzo fisico il necessario
- Il materiale passa per la rete locale LAN giunge al router $\text{S1}$ che fa risalire la pila di livelli fino al livello $3$ per capire tutte le informazioni che gli sono state inviate (e per capire come dovrÃ  instradare il pacchetto). Finalmente invia (riscendendo la pila) il pacchetto verso l'esterno, in particolare verso una WAN
- Il flusso arriva proprio al router $\text{S3}$ grazie alle informazioni descritte e si effettua il solito passaggio di risalita della pila per capire dove dovrÃ  inviare il dato e poi riscendendo la pila invia effettivamente il dato verso la rete LAN in cui risiede il dispositivo D
- La rete LAN filtra la richiesta e manda tutto a D
- D riceve il pacchetto

---

### LIVELLO IP
![[Pasted image 20220713164626.png|300]]

- *Lunghezza minima intestazione*: parte in rosso $\to$ 5 righe ciascuna di 4 byte (in tutto quindi 20 btye - sono sempre presenti);
- *Opzioni aggiuntive*: option e padding

#### NEL DETTAGLIO

1Â° riga:
- **Version**: specifica la versione del protocollo IP (esempio: IPv4)
- **IHL**: Intermediate Header Lenght (lunghezza intestazione intermedia) - specifica l'effettiva lunghezza della intestazione (almeno 20 byte {parte rossa}, ma se ci sono le opzioni aggiuntive Ã¨ piÃ¹ lunga)
- **TOS**: Type of service - serve a identificare il tipo di servizio associato al datagramma e di conseguenza le politiche di gestione (attraverso il livello rete possono essere eseguite diversi servizi (es. voip / traffico dati). Ognuno avrÃ  le sue criticitÃ . Con il TOS si aiutano i dispositivi di rete a gestire al meglio il datagramma o permettono un inoltro migliore sulla rete). Si cerca quindi ad esempio di dare maggiore prioritÃ  a determinati percorsi - Ã¨ lungo 8 bit
- **Total length**: specifica lunghezza effettiva in byte del datagramma (header + payload) - Ã¨ lungo 16 bit (quindi lunghezza massima $2^{16}-1$ bit)

2Â° riga {informazioni per gestire reti non omogenee, che hanno ad esempio dimensioni diverse per quanto riguarda il campo data link}:
- **Identification**: Ã¨ una etichetta per i datagrammi che utilizzano questo protocollo - serve in ricezione per poter riconoscere che un certo datagramma (pacchetto) appartiene a un determinato flusso. Utilizzato per la frammentazione (operazione di suddivisione di un datagramma in parti con formati compatibili con il livello $host \ to \ network$ ) - lungo 16 bit
- **Flag:** Ãˆ lungo 3 bit:
	- il primo Ã¨ detto $\text{bit D}$: se vale $1$, allora il datagramma non puÃ² essere frammentato (se arriva a un router che interfaccia una rete di inoltro con formato di trasferimento non compatibile allora il frammento viene scartato - tanto l'IP come livello Ã¨ non affidabile, quindi un pacchetto puÃ² essere talvolta scartato)
	- il secondo Ã¨ detto $\text{bit M}$: serve per gestire l'invio dei frammenti (se vale $1$, vuol dire che successivamente seguirÃ  un altro frammento. Se vale $0$, allora tale frammento Ã¨ l'ultimo della sequenza, quindi dovrebbe essere stato inviato tutto: sarÃ  quindi inviato al livello successivo che eventualmente esegue il controllo d'integritÃ )
	- il terzo bit non Ã¨ utilizzato
- **Fragment offset** (piazzamento frammento): viene usato per individuare la posizione del primo byte del frammento rispetto alla intera struttura del datagramma - Ã¨ lungo 13 bit
- **TTL** (Time To Live): tempo massimo di vita del datagramma nella rete (se vale zero viene scartato - Ã¨ associato spesso al numero di router/dispositivi che puÃ² attraversare: ogni volta che ne incontra uno, viene decrementato di uno questo valore [scandisce il tempo di vita - evita il problema della "inondazione": troppi router di passaggio]) - Ã¨ lungo 8 bit
- **Protocol**: identifica il tipo di protocollo e quindi il relativo servizio dello strato superiore (trasporto) a cui il datagramma va indirizzato (identifica il servizio TCP oppure UDP) - Ã¨ lungo 8 bit
- **Header Checksum**: consente di garantire che non ci siano errori (di trasmissione) nel campo di testata (attraverso un confronto tra specifica mittente e specifica destinatario {cfr. dopo}) Svantaggio: tempo e modalitÃ  con cui viene utilizzato: ogni volta che le informazioni nella testata subiscono variazioni, Ã¨ necessario riscrivere il campo (ha un impatto ad esempio quando si utilizza la frammentazione, in cui si riscrive ogni volta l'offset o talvolta anche i campi di flag - problemi anche quando cambia il destination address etc...). Riassumendo: utile per evitare errori ma rallenta la velocitÃ  di trasmissione - Ã¨ lungo 16 bit

3Â° e 4Â° riga:
- **Source address**: indirizzo di sorgente - Ã¨ lungo 32 bit ($2^{32}-1$ possibili indirizzi)
- **Destination address**: indirizzo di destinazione - Ã¨ lungo 32 bit ($2^{32}-1$ possibili indirizzi)

6Â° riga (opzionale):
- **Option**: vari utilizzi:
	- utile per implementare un *servizio di sicurezza* (ad esempio nascondere i dati {payload} che si stanno trasmettendo con metodi crittografici - rendere inaccessibile a chi non Ã¨ autorizzato)
	- utile per l'*istradamento dalla sorgente* (se vogliamo individuare il percorso migliore da una certa sorgente a una certa destinazione senza conoscere la rete com'Ã¨ fatta allora si invia un "pacchetto esploratore" in modalitÃ  broadcast con TTL settato a 1 si scoprono tutte le strade di "andata (fino alla destinazione) e ritorno (fino alla sorgente)"- di queste si sceglie quella che arriva prima, che Ã¨ la migliore) - nel campo option si tiene traccia degli indirizzi di ciascun nodo (dispositivo) a cui si giunge, cosÃ¬ da avere tutte le informazioni che servono poi per specificare il percorso (servono quindi per $\text{gestire il routing}$)
	- utile per *controllare la congestione della rete* (tenere traccia di quanto tempo ci mette un dispositivo a elaborare il datagramma)
	- altri utilizzi...
- **Padding**: valori di riempimento (fittizi) per arrivare a $32 \text{ bit}$. Sono aggregato sulla stessa riga di options

---

### FRAMMENTAZIONE E RICOMBINAZIONE
Utile introdurre una misura:
- **MTU**: Maximum Transmission Unit (valore massimo delle dimensioni del datagramma accettate dalla rete di inoltro su cui si appoggia il layer IP)

Facciamo un esempio numerico per capire:
Un host vuole inviare un datagramma su una rete TCP/IP di dimensione 4000 byte totali (payload + almeno 20 byte della testata)
- Si suppone che questo sia riferito a una rete $ethernet$ per la quale il formato accettato Ã¨ di $L_{M}=1500 \text{ byte}$.
Si deve quindi procedere alla frammentazione (essendo $4000 > 1500$)
##### VINCOLI:
- ogni frammento deve avere una propria testata IP 
- tutti i frammenti eccetto l'ultimo devono avere una lunghezza multiplo intero di 8 byte (se non lo sono, vanno completato con bit "fittizi", e nel caso quindi non si sfrutta al massimo la rete $\to$ svantaggio)
#### PROGETTO
Abbiamo che:
- $L_{M}=1500$
	- Di cui: $1480$ byte payload & $20$ byte testata 

Fortunatamente $1480$ Ã¨ un multiplo intero di $8$, quindi non c'Ã¨ bisogno di utilizzare alcun campo (bit) fittizio
#### frammentazione
Per gestire la frammentazione si deve definire il valore in binario dei seguenti campi (2Â° riga):
- Identificatore (ID)
- Flag
- Fragment offset (spiazzamento)
![[Pasted image 20220714163049.png|300]]
- si partiziona il contenuto informativo quando il pacchetto deve passare attraverso la rete Ethernet
	- i datagrammi di dimensioni piÃ¹ piccoli (partizionati) hanno ciascuno il medesimo $header$
	- l'**end-user** esegue poi la **ricostruzione**

![[Pasted image 20220714163522.png|400]]

- Nota: il campo ID viene scelto in maniera aleatoria, e identifica come giÃ  visto il datagramma (infatti tutti i frammenti hanno lo stesso ID)

ðŸ˜¡: ritardo consegna - l'operazione di frammentazione ha un suo tempo di esecuzione
ðŸ˜¡: sicurezza - un hacker esterno puÃ² mandare pacchetti piccoli con numero di spiazzamento casuali o nulli o che magari si sovrappongono con quelli giÃ  inviati/ricevuti (in modo che il sistema di ricezione, "confuso", collassa) {nell'IPv6 sarÃ  implementato in maniera piÃ¹ intelligente};
ðŸ˜¡: poca flessibilitÃ /tolleranza: se qualche frammento non arriva a destinazione, viene scartato l'intero pacchetto {solo se il livello trasporto usa TCP si puÃ² avere speranze di recupero}


### INDIRIZZAMENTO
- Sintassi per scrivere i campi del datagramma volta a una migliore gestione degli indirizzi IP in generale

Un indirizzo IP (4 byte - 32 bit) Ã¨ suddiviso in due parti:
- $\text{NET ID}$: identifica la **rete** di appartenenza del terminale host
- $\text{HOST ID}$: identifica lo specifico terminale (**host**) all'interno di una rete

Ci sono varie modalitÃ  di divisione/indirizzamento, vediamo le principali:
#### INDIRIZZI BASATI SULLE CLASSI
- 5 classi: $\text{A,B,C,D,E}$
	- Sono utilizzati per scopi comuni solo le prime $3$, ovvero: $\text{A,B,C}$
![[Pasted image 20220714164844.png|400]]
- Ogni classe ha un suo "metodo di divisione dei bit" circa i campi NET ID e HOST ID

- Se il primo bit Ã¨ $0$, allora Ã¨ di classe $\text{A}$, altrimenti se vale $1$ puÃ² essere solo $\text{B,C,D,E}$
- Se i primi due bit sono $10$, allora Ã¨ di classe $\text{B}$, altrimenti se sono $11$ puÃ² essere solo $\text{C,D,E}$
- Se i primi tre bit sono $110$, allora Ã¨ di classe $\text{C}$, altrimenti se sono $111$ puÃ² essere solo $\text{D,E}$
- Se i primi quattro bit sono $1110$, allora Ã¨ di classe $\text{D}$, altrimenti se sono $1111$ puÃ² essere solo $\text{E}$

La classe $\text{A}$ Ã¨ destinata ad applicazioni con:
- Poche reti
- Numero alto di Host

La classe $\text{B}$ Ã¨ destinata ad applicazioni con:
- PiÃ¹ reti
- Un po' meno host

La classe $\text{C}$ Ã¨ destinata ad applicazioni con:
- Tante reti
- Pochi host


ðŸ˜ƒ: standardizzato - piÃ¹ facile per la macchina comprendere l'indirizzo
ðŸ˜¡: spreco di indirizzi - dato che ogni router dovrebbe assegnare un NET ID con potenziali indirizzi non utilizzati 

> Con la tecnica del **subnetting** si puÃ² dividere il NET ID in piÃ¹ parti, cosÃ¬ che bastano meno indirizzi gestire lo stesso numero di dispositivi, evitando sprechi inutili

### SUBNETTING
- Maschera di rete che partiziona l'insieme di HOST ID indirizzati in sottoinsiemi. Essi vengono associati allo stesso NET ID.

#### indirizzo senza classi
- I campi NET ID e HOST ID hanno dimensione variabili, non esistono quindi vincoli di dimensioni dei campi
ðŸ˜ƒ: piÃ¹ flessibile
ðŸ˜¡: piÃ¹ complicato per la macchina


#### NAT
- Network Address Translation (Traduttore Indrizzi di Rete)
Ad ogni **rete** viene assegnato un solo indirizzo IP
- Per le comunicazioni interne si utilizzano indirizzi privati, che hanno valenza cioÃ¨ solo all'interno della rete
- Quando un host della rete decide di aprire una comunicazione con un dispositivo esterno alla rete sorgente, si mostrerÃ  con l'indirizzo pubblico attribuito alla rete
	- ðŸ˜¡: diventa piÃ¹ complicato in fase di ricezione capire l'esatto dispositivo che ha fatto una richiesta, perchÃ© appare solo l'indirizzo della rete
	- ðŸ˜ƒ: meno spreco di indirizzi - una rete con $n$ dispositivi ha bisogno solo di un unico indirizzo per interfacciarsi
	- 


#### NOTAZIONE DEGLI INDIRIZZI: DECIMALE PUNTATA
- 4 numeri (veicolati con il loro valore in binario) separati da un punto
Esempio:
![[Pasted image 20220714172139.png|500]]

Fissata la classe dell'indirizzo (esempio classe $\text{B}$), si assegna la possibilitÃ  di inserire gli indicatori di HOST ID e SUBNET ID nel campo originariamente previsto solo per le informazioni di HOST ID
- Prendendo la classe $\text{B}$ come esempio abbiamo $2$ byte da gestire per l'HOST ID. Con questa nuova modalitÃ  i medesimi $2$ byte possono essere gestiti per HOST ID e SUBNET ID
- Nota: i router leggono solo *i primi due campi* che rappresentano la rete (NET ID)
	- I $2$ byte suddetti della classe $\text{B}$ hanno una *importanza locale* (della sottorete in considerazione, perchÃ© verso l'esterno come detto si interfacciano con un unico indirizzo)

##### MASCHERA DI RETE (SUBNET MASK)
- Serve per definire i "confini" dei sottoindirizzi di una rete (NET ID)
- Vale $1$ nelle posizioni di NET ID
- Vale $0$ nelle posizioni di SUBNET ID
L'esempio piÃ¹ comune Ã¨ il seguente (classe $\text{B}$):
$$
255.255.255.0 \longleftrightarrow \underbrace{11111111.11111111}_{\text{NET ID}}.\underbrace{11111111}_{\text{SUBNET ID}}.\underbrace{00000000}_{\text{HOST ID}}
$$
In questo caso:
- I primi 2 byte sono dedicati a NET ID (per com'Ã¨ definita la classe $\text{B}$)
- Il terzo byte Ã¨ relativo al SUBNET ID
- Si lascia libero (solo) l'ultimo byte per indirizzare gli host locali (HOST ID)

Per poter *estrarre* le informazioni necessarie per gestire l'operazione d'inoltro ai router, per ogni rete raggiungibile abbiamo in memoria le maschere di rete associate
La **procedura** Ã¨ la seguente:
- AND logico per individuare le informazioni circa la maschera di rete (se trovo $0$ invece vuol dire che ho trovato le informazioni dell'host id)

Esempio:
Ad un campus universitario Ã¨ stato assegnato un indirizzo IP di classe $\text{B}$ seguente:
$$
150.10.0.0
$$
AvrÃ  maschera di sottorete, essendo di classe $\text{B}$:
$$
255.255.255.0 \longleftrightarrow \underbrace{11111111.11111111}_{\text{NET ID}}.\overbrace{\underbrace{11111111}_{\text{SUBNET ID}}.\underbrace{00000000}_{\text{HOST ID}}}^{\text{LOCALE}}
$$

#### INDIRIZZI SENZA CLASSI: COME VIENE GESTITO IL SUBNETTING
Vediamo con un esempio: si vogliono gestire $1000$ indirizzi ($10^{3}$) 
- Si devono assegnare rispettando la regola di avere un numero finale espresso come potenza di intera di due: avendo $1000$ indirizzi, avremo come riferimento $1024$, ovvero $2^{10}$ (quindi $10$ bit per l'HOST ID e i restanti $22$ per la maschera)
In notazione senza classi:
$$
\text{w.y.z.k}/n  \quad , \quad \text{nel nostro caso: } \text{w.y.z.k}/22
$$

### CIDR
Esempio:
- A una sottorete Ã¨ stato allocato un blocco di $1024$ indirizzi, cosÃ¬ localizzato:
$$
\text{da } 200.30.0.0 \quad \text{a } 200.30.3.255
$$
> Trovare la maschera di sottorete

- Traduciamo in binario
$$
\begin{gather}
200.30.0.0 &\longleftrightarrow &11001000.00011110.00000000.00000000 \\
200.30.3.255 &\longleftrightarrow &\underbrace{11001000.00011110.000000}11.11111111
\end{gather}
$$
Facendo l'AND logico, si ottiene la maschera:
$$
255.255.252.0 \longleftrightarrow 11001000.00011110.00000011.00000000
$$

#### OPERAZIONE DI ROUTING
- Operazione di "matching" binario:
La maschera Ã¨ memorizzata nel router nel router insieme al NET ID
- Il router 