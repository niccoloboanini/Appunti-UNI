## PROTOCOLLO TCP-IP
- Detto anche modello $internet$
- Architettura a livelli basata su quanto visto nel caso $\text{ISO-OSI}$ (seppur semplificata)

![[Pasted image 20220713152654.png|250]]

### PANORAMICA DEI LIVELLI
#### 1) HOST TO NETWORK
Definito in maniera generica perch√© adattabile a pi√π contesti
- Permette la possibilit√† di usufruire del protocollo TCP-IP anche tra reti eterogenee, cio√® tra reti che hanno livello collegamento e fisico diversi (cos√¨ che il protocollo diventa adattabile a pi√π contesti)

#### 2) INTERNET
Livello rete (IP): permette di configurare la rete in modo tale da consentire lo scambio di pacchetti tra nodi della rete
- Si preoccupa dell'*instradamento*, cio√® la modalit√† con cui l'informazione viene gestita nella rete circa i percorsi che deve fare (di default √® a datagramma, quindi $connectionless$, sar√† poi eventualmente il livello trasporto a implementare tecniche di $connection \ oriented$)
> Riassumendo: Gestisce lo scambio di pacchetti tra coppie sorgente-destinazione in modalit√† $connectionless$ non affidabile (no controllo integrit√†). E' attivato in modalit√† link-to-link (tutti i nodi della rete hanno libello rete)

#### 3) TRASPORTO
Detto anche TCP: definisce e attua le modalit√† di scambio di pacchetti ($connection \ oriented$, $connectionless$...) - come nell'ISO-OSI
- I pacchetti scambiati/generati a questo livello sono detti $datagram$
- √à attivato su base end-to-end (implementa quindi eventualmente il controllo integrit√†)
	- Quindi rende possibili entrambe le modalit√† $connection \ oriented$ e $connectionless$
- Controlla talvolta (e implementa) il controllo dell'integrit√† della informazione ricevuta

#### 4) APPLICAZIONE
Analogo al caso ISO-OSI

> [!abstract] Livelli Mancanti rispetto a ISO-OSI (sessione, presentazione). Perch√©?
> Primo motivo: √® nata prima dell'ISO-OSI
> Era storicamente pensata per un unico fornitore (quindi ad esempio non serviva il livello presentazione perch√© il formato si supponeva univoco)
> 

---
### ESEMPIO DI COLLEGAMENTO
![[Pasted image 20220713154610.png|400]]

*A vuole connettersi a D*
A apre il collegamento (magari a livello applicazione) e inizia il viaggio dei pacchetti:
- Dal livello rete di A si scende fino al livello fisico passando dal livello collegamento, e si invia tramite il mezzo fisico il necessario
- Il materiale passa per la rete locale LAN giunge al router $\text{S1}$ che fa risalire la pila di livelli fino al livello $3$ per capire tutte le informazioni che gli sono state inviate (e per capire come dovr√† instradare il pacchetto). Finalmente invia (riscendendo la pila) il pacchetto verso l'esterno, in particolare verso una WAN
- Il flusso arriva proprio al router $\text{S3}$ grazie alle informazioni descritte e si effettua il solito passaggio di risalita della pila per capire dove dovr√† inviare il dato e poi riscendendo la pila invia effettivamente il dato verso la rete LAN in cui risiede il dispositivo D
- La rete LAN filtra la richiesta e manda tutto a D
- D riceve il pacchetto

---

### LIVELLO IP
![[Pasted image 20220713164626.png|300]]

- *Lunghezza minima intestazione*: parte in rosso $\to$ 5 righe ciascuna di 4 byte (in tutto quindi 20 btye - sono sempre presenti);
- *Opzioni aggiuntive*: option e padding

#### NEL DETTAGLIO

1¬∞ riga:
- **Version**: specifica la versione del protocollo IP (esempio: IPv4)
- **IHL**: Intermediate Header Lenght (lunghezza intestazione intermedia) - specifica l'effettiva lunghezza della intestazione (almeno 20 byte {parte rossa}, ma se ci sono le opzioni aggiuntive √® pi√π lunga)
- **TOS**: Type of service - serve a identificare il tipo di servizio associato al datagramma e di conseguenza le politiche di gestione (attraverso il livello rete possono essere eseguite diversi servizi (es. voip / traffico dati). Ognuno avr√† le sue criticit√†. Con il TOS si aiutano i dispositivi di rete a gestire al meglio il datagramma o permettono un inoltro migliore sulla rete). Si cerca quindi ad esempio di dare maggiore priorit√† a determinati percorsi - √® lungo 8 bit
- **Total length**: specifica lunghezza effettiva in byte del datagramma (header + payload) - √® lungo 16 bit (quindi lunghezza massima $2^{16}-1$ bit)

2¬∞ riga {informazioni per gestire reti non omogenee, che hanno ad esempio dimensioni diverse per quanto riguarda il campo data link}:
- **Identification**: √® una etichetta per i datagrammi che utilizzano questo protocollo - serve in ricezione per poter riconoscere che un certo datagramma (pacchetto) appartiene a un determinato flusso. Utilizzato per la frammentazione (operazione di suddivisione di un datagramma in parti con formati compatibili con il livello $host \ to \ network$ ) - lungo 16 bit
- **Flag:** √à lungo 3 bit:
	- il primo √® detto $\text{bit D}$: se vale $1$, allora il datagramma non pu√≤ essere frammentato (se arriva a un router che interfaccia una rete di inoltro con formato di trasferimento non compatibile allora il frammento viene scartato - tanto l'IP come livello √® non affidabile, quindi un pacchetto pu√≤ essere talvolta scartato)
	- il secondo √® detto $\text{bit M}$: serve per gestire l'invio dei frammenti (se vale $1$, vuol dire che successivamente seguir√† un altro frammento. Se vale $0$, allora tale frammento √® l'ultimo della sequenza, quindi dovrebbe essere stato inviato tutto: sar√† quindi inviato al livello successivo che eventualmente esegue il controllo d'integrit√†)
	- il terzo bit non √® utilizzato
- **Fragment offset** (piazzamento frammento): viene usato per individuare la posizione del primo byte del frammento rispetto alla intera struttura del datagramma - √® lungo 13 bit
- **TTL** (Time To Live): tempo massimo di vita del datagramma nella rete (se vale zero viene scartato - √® associato spesso al numero di router/dispositivi che pu√≤ attraversare: ogni volta che ne incontra uno, viene decrementato di uno questo valore [scandisce il tempo di vita - evita il problema della "inondazione": troppi router di passaggio]) - √® lungo 8 bit
- **Protocol**: identifica il tipo di protocollo e quindi il relativo servizio dello strato superiore (trasporto) a cui il datagramma va indirizzato (identifica il servizio TCP oppure UDP) - √® lungo 8 bit
- **Header Checksum**: consente di garantire che non ci siano errori (di trasmissione) nel campo di testata (attraverso un confronto tra specifica mittente e specifica destinatario {cfr. dopo}) Svantaggio: tempo e modalit√† con cui viene utilizzato: ogni volta che le informazioni nella testata subiscono variazioni, √® necessario riscrivere il campo (ha un impatto ad esempio quando si utilizza la frammentazione, in cui si riscrive ogni volta l'offset o talvolta anche i campi di flag - problemi anche quando cambia il destination address etc...). Riassumendo: utile per evitare errori ma rallenta la velocit√† di trasmissione - √® lungo 16 bit

3¬∞ e 4¬∞ riga:
- **Source address**: indirizzo di sorgente - √® lungo 32 bit ($2^{32}-1$ possibili indirizzi)
- **Destination address**: indirizzo di destinazione - √® lungo 32 bit ($2^{32}-1$ possibili indirizzi)

6¬∞ riga (opzionale):
- **Option**: vari utilizzi:
	- utile per implementare un *servizio di sicurezza* (ad esempio nascondere i dati {payload} che si stanno trasmettendo con metodi crittografici - rendere inaccessibile a chi non √® autorizzato)
	- utile per l'*istradamento dalla sorgente* (se vogliamo individuare il percorso migliore da una certa sorgente a una certa destinazione senza conoscere la rete com'√® fatta allora si invia un "pacchetto esploratore" in modalit√† broadcast con TTL settato a 1 si scoprono tutte le strade di "andata (fino alla destinazione) e ritorno (fino alla sorgente)"- di queste si sceglie quella che arriva prima, che √® la migliore) - nel campo option si tiene traccia degli indirizzi di ciascun nodo (dispositivo) a cui si giunge, cos√¨ da avere tutte le informazioni che servono poi per specificare il percorso (servono quindi per $\text{gestire il routing}$)
	- utile per *controllare la congestione della rete* (tenere traccia di quanto tempo ci mette un dispositivo a elaborare il datagramma)
	- altri utilizzi...
- **Padding**: valori di riempimento (fittizi) per arrivare a $32 \text{ bit}$. Sono aggregato sulla stessa riga di options

---

### FRAMMENTAZIONE E RICOMBINAZIONE
Utile introdurre una misura:
- **MTU**: Maximum Transmission Unit (valore massimo delle dimensioni del datagramma accettate dalla rete di inoltro su cui si appoggia il layer IP)

Facciamo un esempio numerico per capire:
Un host vuole inviare un datagramma su una rete TCP/IP di dimensione 4000 byte totali (payload + almeno 20 byte della testata)
- Si suppone che questo sia riferito a una rete $ethernet$ per la quale il formato accettato √® di $L_{M}=1500 \text{ byte}$.
Si deve quindi procedere alla frammentazione (essendo $4000 > 1500$)
##### VINCOLI:
- ogni frammento deve avere una propria testata IP 
- tutti i frammenti eccetto l'ultimo devono avere una lunghezza multiplo intero di 8 byte (se non lo sono, vanno completato con bit "fittizi", e nel caso quindi non si sfrutta al massimo la rete $\to$ svantaggio)
#### PROGETTO
Abbiamo che:
- $L_{M}=1500$
	- Di cui: $1480$ byte payload & $20$ byte testata 

Fortunatamente $1480$ √® un multiplo intero di $8$, quindi non c'√® bisogno di utilizzare alcun campo (bit) fittizio
#### frammentazione
Per gestire la frammentazione si deve definire il valore in binario dei seguenti campi (2¬∞ riga):
- Identificatore (ID)
- Flag
- Fragment offset (spiazzamento)
![[Pasted image 20220714163049.png|300]]
- si partiziona il contenuto informativo quando il pacchetto deve passare attraverso la rete Ethernet
	- i datagrammi di dimensioni pi√π piccoli (partizionati) hanno ciascuno il medesimo $header$
	- l'**end-user** esegue poi la **ricostruzione**

![[Pasted image 20220714163522.png|400]]

- Nota: il campo ID viene scelto in maniera aleatoria, e identifica come gi√† visto il datagramma (infatti tutti i frammenti hanno lo stesso ID)

üò°: ritardo consegna - l'operazione di frammentazione ha un suo tempo di esecuzione
üò°: sicurezza - un hacker esterno pu√≤ mandare pacchetti piccoli con numero di spiazzamento casuali o nulli o che magari si sovrappongono con quelli gi√† inviati/ricevuti (in modo che il sistema di ricezione, "confuso", collassa) {nell'IPv6 sar√† implementato in maniera pi√π intelligente};
üò°: poca flessibilit√†/tolleranza: se qualche frammento non arriva a destinazione, viene scartato l'intero pacchetto {solo se il livello trasporto usa TCP si pu√≤ avere speranze di recupero}


### INDIRIZZAMENTO
- Sintassi per scrivere i campi del datagramma volta a una migliore gestione degli indirizzi IP in generale

Un indirizzo IP (4 byte - 32 bit) √® suddiviso in due parti:
- $\text{NET ID}$: identifica la **rete** di appartenenza del terminale host
- $\text{HOST ID}$: identifica lo specifico terminale (**host**) all'interno di una rete

Ci sono varie modalit√† di divisione/indirizzamento, vediamo le principali:
#### INDIRIZZI BASATI SULLE CLASSI
- 5 classi: $\text{A,B,C,D,E}$
	- Sono utilizzati per scopi comuni solo le prime $3$, ovvero: $\text{A,B,C}$
![[Pasted image 20220714164844.png|400]]
- Ogni classe ha un suo "metodo di divisione dei bit" circa i campi NET ID e HOST ID

- Se il primo bit √® $0$, allora √® di classe $\text{A}$, altrimenti se vale $1$ pu√≤ essere solo $\text{B,C,D,E}$
- Se i primi due bit sono $10$, allora √® di classe $\text{B}$, altrimenti se sono $11$ pu√≤ essere solo $\text{C,D,E}$
- Se i primi tre bit sono $110$, allora √® di classe $\text{C}$, altrimenti se sono $111$ pu√≤ essere solo $\text{D,E}$
- Se i primi quattro bit sono $1110$, allora √® di classe $\text{D}$, altrimenti se sono $1111$ pu√≤ essere solo $\text{E}$

La classe $\text{A}$ √® destinata ad applicazioni con:
- Poche reti
- Numero alto di Host

La classe $\text{B}$ √® destinata ad applicazioni con:
- Pi√π reti
- Un po' meno host

La classe $\text{C}$ √® destinata ad applicazioni con:
- Tante reti
- Pochi host


üòÉ: standardizzato - pi√π facile per la macchina comprendere l'indirizzo
üò°: spreco di indirizzi - dato che ogni router dovrebbe assegnare un NET ID con potenziali indirizzi non utilizzati 

> Con la tecnica del **subnetting** si pu√≤ dividere il NET ID in pi√π parti, cos√¨ che bastano meno indirizzi gestire lo stesso numero di dispositivi, evitando sprechi inutili

### SUBNETTING
- Maschera di rete che partiziona l'insieme di HOST ID indirizzati in sottoinsiemi. Essi vengono associati allo stesso NET ID.

#### indirizzo senza classi
- I campi NET ID e HOST ID hanno dimensione variabili, non esistono quindi vincoli di dimensioni dei campi
üòÉ: pi√π flessibile
üò°: pi√π complicato per la macchina


#### NAT
- Network Address Translation (Traduttore Indrizzi di Rete)
Ad ogni **rete** viene assegnato un solo indirizzo IP
- Per le comunicazioni interne si utilizzano indirizzi privati, che hanno valenza cio√® solo all'interno della rete
- Quando un host della rete decide di aprire una comunicazione con un dispositivo esterno alla rete sorgente, si mostrer√† con l'indirizzo pubblico attribuito alla rete
	- üò°: diventa pi√π complicato in fase di ricezione capire l'esatto dispositivo che ha fatto una richiesta, perch√© appare solo l'indirizzo della rete
	- üòÉ: meno spreco di indirizzi - una rete con $n$ dispositivi ha bisogno solo di un unico indirizzo per interfacciarsi
	- 


#### NOTAZIONE DEGLI INDIRIZZI: DECIMALE PUNTATA
- 4 numeri (veicolati con il loro valore in binario) separati da un punto
Esempio:
![[Pasted image 20220714172139.png|500]]

Fissata la classe dell'indirizzo (esempio classe $\text{B}$), si assegna la possibilit√† di inserire gli indicatori di HOST ID e SUBNET ID nel campo originariamente previsto solo per le informazioni di HOST ID
- Prendendo la classe $\text{B}$ come esempio abbiamo $2$ byte da gestire per l'HOST ID. Con questa nuova modalit√† i medesimi $2$ byte possono essere gestiti per HOST ID e SUBNET ID
- Nota: i router leggono solo *i primi due campi* che rappresentano la rete (NET ID)
	- I $2$ byte suddetti della classe $\text{B}$ hanno una *importanza locale* (della sottorete in considerazione, perch√© verso l'esterno come detto si interfacciano con un unico indirizzo)

##### MASCHERA DI RETE (SUBNET MASK)
- Serve per definire i "confini" dei sottoindirizzi di una rete (NET ID)

