## PROTOCOLLO TCP-IP
- Detto anche modello $internet$
- Architettura a livelli basata su quanto visto nel caso $\text{ISO-OSI}$ (seppur semplificata)

![[Pasted image 20220713152654.png|250]]

### PANORAMICA DEI LIVELLI
#### 1) HOST TO NETWORK
Definito in maniera generica perché adattabile a più contesti
- Permette la possibilità di usufruire del protocollo TCP-IP anche tra reti eterogenee, cioè tra reti che hanno livello collegamento e fisico diversi (così che il protocollo diventa adattabile a più contesti)

#### 2) INTERNET
Livello rete (IP): permette di configurare la rete in modo tale da consentire lo scambio di pacchetti tra nodi della rete
- Si preoccupa dell'*instradamento*, cioè la modalità con cui l'informazione viene gestita nella rete circa i percorsi che deve fare (di default è a datagramma, quindi $connectionless$, sarà poi eventualmente il livello trasporto a implementare tecniche di $connection \ oriented$)
> Riassumendo: Gestisce lo scambio di pacchetti tra coppie sorgente-destinazione in modalità $connectionless$ non affidabile (no controllo integrità). E' attivato in modalità link-to-link (tutti i nodi della rete hanno libello rete)

#### 3) TRASPORTO
Detto anche TCP: definisce e attua le modalità di scambio di pacchetti ($connection \ oriented$, $connectionless$...) - come nell'ISO-OSI
- I pacchetti scambiati/generati a questo livello sono detti $datagram$
- È attivato su base end-to-end (implementa quindi eventualmente il controllo integrità)
	- Quindi rende possibili entrambe le modalità $connection \ oriented$ e $connectionless$
- Controlla talvolta (e implementa) il controllo dell'integrità della informazione ricevuta

#### 4) APPLICAZIONE
Analogo al caso ISO-OSI

> [!abstract] Livelli Mancanti rispetto a ISO-OSI (sessione, presentazione). Perché?
> Primo motivo: è nata prima dell'ISO-OSI
> Era storicamente pensata per un unico fornitore (quindi ad esempio non serviva il livello presentazione perché il formato si supponeva univoco)
> 

---
### ESEMPIO DI COLLEGAMENTO
![[Pasted image 20220713154610.png|400]]

*A vuole connettersi a D*
A apre il collegamento (magari a livello applicazione) e inizia il viaggio dei pacchetti:
- Dal livello rete di A si scende fino al livello fisico passando dal livello collegamento, e si invia tramite il mezzo fisico il necessario
- Il materiale passa per la rete locale LAN giunge al router $\text{S1}$ che fa risalire la pila di livelli fino al livello $3$ per capire tutte le informazioni che gli sono state inviate (e per capire come dovrà instradare il pacchetto). Finalmente invia (riscendendo la pila) il pacchetto verso l'esterno, in particolare verso una WAN
- Il flusso arriva proprio al router $\text{S3}$ grazie alle informazioni descritte e si effettua il solito passaggio di risalita della pila per capire dove dovrà inviare il dato e poi riscendendo la pila invia effettivamente il dato verso la rete LAN in cui risiede il dispositivo D
- La rete LAN filtra la richiesta e manda tutto a D
- D riceve il pacchetto

---

### LIVELLO IP
![[Pasted image 20220713164626.png|300]]

- *Lunghezza minima intestazione*: parte in rosso $\to$ 5 righe ciascuna di 4 byte (in tutto quindi 20 btye - sono sempre presenti);
- *Opzioni aggiuntive*: option e padding

#### NEL DETTAGLIO

1° riga:
- **Version**: specifica la versione del protocollo IP (esempio: IPv4)
- **IHL**: Intermediate Header Lenght (lunghezza intestazione intermedia) - specifica l'effettiva lunghezza della testata (almeno 20 byte, ma se ci sono le opzioni aggiuntive è più lunga)
- **TOS**: Type of service - serve a identificare il tipo di servizio associato al datagramma e di conseguenza le politiche di gestione (attraverso il livello rete possono essere eseguite diversi servizi (es. voip / traffico dati). Ognuno avrà le sue criticità. Con il TOS si aiutano i dispositivi di rete a gestire al meglio il datagramma o permettono un inoltro migliore sulla rete) - è lungo 8 bit
- **Total length**: specifica lunghezza effettiva in byte della testata - è lungo 16 bit

2° riga {informazioni per gestire reti non omogenee, che hanno ad esempio dimensioni diverse per quanto riguarda il campo data link}:
- **Identification**: è una etichetta per i datagrammi che utilizzano questo protocollo - serve in ricezione per poter riconoscere che un certo datagramma (pacchetto) appartiene a un determinato flusso. Utilizzato per la frammentazione (operazione di suddivisione di un datagramma in parti con formati compatibili con il livello $host \ to \ network$ ) - lungo 16 bit
- **Flag:** È lungo 3 bit:
	- il primo è detto $\text{bit D}$: se vale $1$, allora il datagramma non può essere frammentato (se arriva a un router che interfaccia una rete di inoltro con formato di trasferimento non compatibile allora il frammento viene scartato - tanto l'IP come livello è non affidabile, quindi un pacchetto può essere talvolta scartato)
	- il secondo è detto $\text{bit M}$: serve per gestire l'invio dei frammenti (se vale $1$, vuol dire che successivamente seguirà un altro frammento. Se vale $0$, allora tale frammento è l'ultimo della sequenza, quindi dovrebbe essere stato inviato tutto: sarà quindi inviato al livello successivo che eventualmente esegue il controllo d'integrità)
	- il terzo bit non è utilizzato
- **Fragment offset** (piazzamento frammento): viene usato per individuare la posizione del primo byte del frammento rispetto alla intera struttura del datagramma - è lungo 13 bit
- **TTL** (Time To Live): tempo massimo di vita del datagramma nella rete (se vale zero viene scartato - associato spesso al numero di router che può attraversare: ogni volta che ne incontra uno, esso decrementa di uno questo valore [scandisce il tempo di vita - evita il problema della "inondazione": troppi router di passaggio]) - è lungo 8 bit
- **Protocol**: identifica il tipo di protocollo e quindi il relativo servizio dello strato superiore (trasporto) a cui il datagramma va indirizzato (identifica il servizio TCP oppure UDP) - è lungo 8 bit
- **Header Checksum**: consente di garantire che non ci siano errori (di trasmissione) nel campo di testata (attraverso un confronto tra specifica mittente e specifica destinatario {cfr. dopo}) Svantaggio: tempo e modalità con cui viene utilizzato: ogni volta che le informazioni nella testata subiscono variazioni, è necessario riscrivere il campo (ha un impatto ad esempio quando si utilizza la frammentazione, in cui si riscrive ogni volta l'offset o talvolta anche i campi di flag - problemi anche quando cambia il destination address etc...). Riassumendo: utile ma rallenta la velocità di trasmissione - è lungo 16 bit

3° e 4° riga:
- **Source address**: indirizzo di sorgente - è lungo 32 bit ($2^{32}-1$ possibili indirizzi)
- **Destination address**: indirizzo di destinazione - è lungo 32 bit ($2^{32}-1$ possibili indirizzi)

6° riga (opzionale):
- **Option**: vari utilizzi:
	- utile per implementare un *servizio di sicurezza* (ad esempio nascondere i dati {payload} che si stanno trasmettendo con metodi crittografici - rendere inaccessibile a chi non è autorizzato)
	- utile per l'*istradamento dalla sorgente* (se vogliamo individuare il percorso migliore da una certa sorgente a una certa destinazione senza conoscere la rete com'è fatta allora si invia un "pacchetto esploratore" in modalità broadcast con TTL settato a 1 si scoprono tutte le strade di "andata (fino alla destinazione) e ritorno (fino alla sorgente)"- di queste si sceglie quella che arriva prima, che è la migliore) - nel campo option si tiene traccia della identità di ciascun nodo a cui si giunge, così da avere tutte le informazioni che servono poi per specificare il percorso (servono quindi per $\text{gestire il routing}$)
	- utile per *controllare la congestione della rete*
	- altri utilizzi...
- **Padding**: ???