## PROTOCOLLO TCP-IP
- Detto anche modello $internet$
- Architettura a livelli basata su quanto visto nel caso $\text{ISO-OSI}$ (seppur semplificata)

![[Pasted image 20220713152654.png|250]]

### PANORAMICA DEI LIVELLI
#### 1) HOST TO NETWORK
Definito in maniera generica perch√© adattabile a pi√π contesti
- Permette la possibilit√† di usufruire del protocollo TCP-IP anche tra reti eterogenee, cio√® tra reti che hanno livello collegamento e fisico diversi (cos√¨ che il protocollo diventa adattabile a pi√π contesti)

#### 2) INTERNET
Livello rete (IP): permette di configurare la rete in modo tale da consentire lo scambio di pacchetti tra nodi della rete
- Si preoccupa dell'*instradamento*, cio√® la modalit√† con cui l'informazione viene gestita nella rete circa i percorsi che deve fare (di default √® a datagramma, quindi $connectionless$, sar√† poi eventualmente il livello trasporto a implementare tecniche di $connection \ oriented$)
> Riassumendo: Gestisce lo scambio di pacchetti tra coppie sorgente-destinazione in modalit√† $connectionless$ non affidabile (no controllo integrit√†). E' attivato in modalit√† link-to-link (tutti i nodi della rete hanno libello rete)

#### 3) TRASPORTO
Detto anche TCP: definisce e attua le modalit√† di scambio di pacchetti ($connection \ oriented$, $connectionless$...) - come nell'ISO-OSI
- I pacchetti scambiati/generati a questo livello sono detti $datagram$
- √à attivato su base end-to-end (implementa quindi eventualmente il controllo integrit√†)
	- Quindi rende possibili entrambe le modalit√† $connection \ oriented$ e $connectionless$
- Controlla talvolta (e implementa) il controllo dell'integrit√† della informazione ricevuta

#### 4) APPLICAZIONE
Analogo al caso ISO-OSI

> [!abstract] Livelli Mancanti rispetto a ISO-OSI (sessione, presentazione). Perch√©?
> Primo motivo: √® nata prima dell'ISO-OSI
> Era storicamente pensata per un unico fornitore (quindi ad esempio non serviva il livello presentazione perch√© il formato si supponeva univoco)
> 

---
### ESEMPIO DI COLLEGAMENTO
![[Pasted image 20220713154610.png|400]]

*A vuole connettersi a D*
A apre il collegamento (magari a livello applicazione) e inizia il viaggio dei pacchetti:
- Dal livello rete di A si scende fino al livello fisico passando dal livello collegamento, e si invia tramite il mezzo fisico il necessario
- Il materiale passa per la rete locale LAN giunge al router $\text{S1}$ che fa risalire la pila di livelli fino al livello $3$ per capire tutte le informazioni che gli sono state inviate (e per capire come dovr√† instradare il pacchetto). Finalmente invia (riscendendo la pila) il pacchetto verso l'esterno, in particolare verso una WAN
- Il flusso arriva proprio al router $\text{S3}$ grazie alle informazioni descritte e si effettua il solito passaggio di risalita della pila per capire dove dovr√† inviare il dato e poi riscendendo la pila invia effettivamente il dato verso la rete LAN in cui risiede il dispositivo D
- La rete LAN filtra la richiesta e manda tutto a D
- D riceve il pacchetto

---

### LIVELLO IP
![[Pasted image 20220713164626.png|300]]

- *Lunghezza minima intestazione*: parte in rosso $\to$ 5 righe ciascuna di 4 byte (in tutto quindi 20 btye - sono sempre presenti);
- *Opzioni aggiuntive*: option e padding

#### NEL DETTAGLIO

1¬∞ riga:
- **Version**: specifica la versione del protocollo IP (esempio: IPv4)
- **IHL**: Intermediate Header Lenght (lunghezza intestazione intermedia) - specifica l'effettiva lunghezza della intestazione (almeno 20 byte {parte rossa}, ma se ci sono le opzioni aggiuntive √® pi√π lunga)
- **TOS**: Type of service - serve a identificare il tipo di servizio associato al datagramma e di conseguenza le politiche di gestione (attraverso il livello rete possono essere eseguite diversi servizi (es. voip / traffico dati). Ognuno avr√† le sue criticit√†. Con il TOS si aiutano i dispositivi di rete a gestire al meglio il datagramma o permettono un inoltro migliore sulla rete). Si cerca quindi ad esempio di dare maggiore priorit√† a determinati percorsi - √® lungo 8 bit
- **Total length**: specifica lunghezza effettiva in byte del datagramma (header + payload) - √® lungo 16 bit (quindi lunghezza massima $2^{16}-1$ bit)

2¬∞ riga {informazioni per gestire reti non omogenee, che hanno ad esempio dimensioni diverse per quanto riguarda il campo data link}:
- **Identification**: √® una etichetta per i datagrammi che utilizzano questo protocollo - serve in ricezione per poter riconoscere che un certo datagramma (pacchetto) appartiene a un determinato flusso. Utilizzato per la frammentazione (operazione di suddivisione di un datagramma in parti con formati compatibili con il livello $host \ to \ network$ ) - lungo 16 bit
- **Flag:** √à lungo 3 bit:
	- il primo √® detto $\text{bit D}$: se vale $1$, allora il datagramma non pu√≤ essere frammentato (se arriva a un router che interfaccia una rete di inoltro con formato di trasferimento non compatibile allora il frammento viene scartato - tanto l'IP come livello √® non affidabile, quindi un pacchetto pu√≤ essere talvolta scartato)
	- il secondo √® detto $\text{bit M}$: serve per gestire l'invio dei frammenti (se vale $1$, vuol dire che successivamente seguir√† un altro frammento. Se vale $0$, allora tale frammento √® l'ultimo della sequenza, quindi dovrebbe essere stato inviato tutto: sar√† quindi inviato al livello successivo che eventualmente esegue il controllo d'integrit√†)
	- il terzo bit non √® utilizzato
- **Fragment offset** (piazzamento frammento): viene usato per individuare la posizione del primo byte del frammento rispetto alla intera struttura del datagramma - √® lungo 13 bit
- **TTL** (Time To Live): tempo massimo di vita del datagramma nella rete (se vale zero viene scartato - √® associato spesso al numero di router/dispositivi che pu√≤ attraversare: ogni volta che ne incontra uno, viene decrementato di uno questo valore [scandisce il tempo di vita - evita il problema della "inondazione": troppi router di passaggio]) - √® lungo 8 bit
- **Protocol**: identifica il tipo di protocollo e quindi il relativo servizio dello strato superiore (trasporto) a cui il datagramma va indirizzato (identifica il servizio TCP oppure UDP) - √® lungo 8 bit
- **Header Checksum**: consente di garantire che non ci siano errori (di trasmissione) nel campo di testata (attraverso un confronto tra specifica mittente e specifica destinatario {cfr. dopo}) Svantaggio: tempo e modalit√† con cui viene utilizzato: ogni volta che le informazioni nella testata subiscono variazioni, √® necessario riscrivere il campo (ha un impatto ad esempio quando si utilizza la frammentazione, in cui si riscrive ogni volta l'offset o talvolta anche i campi di flag - problemi anche quando cambia il destination address etc...). Riassumendo: utile per evitare errori ma rallenta la velocit√† di trasmissione - √® lungo 16 bit

3¬∞ e 4¬∞ riga:
- **Source address**: indirizzo di sorgente - √® lungo 32 bit ($2^{32}-1$ possibili indirizzi)
- **Destination address**: indirizzo di destinazione - √® lungo 32 bit ($2^{32}-1$ possibili indirizzi)

6¬∞ riga (opzionale):
- **Option**: vari utilizzi:
	- utile per implementare un *servizio di sicurezza* (ad esempio nascondere i dati {payload} che si stanno trasmettendo con metodi crittografici - rendere inaccessibile a chi non √® autorizzato)
	- utile per l'*istradamento dalla sorgente* (se vogliamo individuare il percorso migliore da una certa sorgente a una certa destinazione senza conoscere la rete com'√® fatta allora si invia un "pacchetto esploratore" in modalit√† broadcast con TTL settato a 1 si scoprono tutte le strade di "andata (fino alla destinazione) e ritorno (fino alla sorgente)"- di queste si sceglie quella che arriva prima, che √® la migliore) - nel campo option si tiene traccia degli indirizzi di ciascun nodo (dispositivo) a cui si giunge, cos√¨ da avere tutte le informazioni che servono poi per specificare il percorso (servono quindi per $\text{gestire il routing}$)
	- utile per *controllare la congestione della rete* (tenere traccia di quanto tempo ci mette un dispositivo a elaborare il datagramma)
	- altri utilizzi...
- **Padding**: valori di riempimento (fittizi) per arrivare a $32 \text{ bit}$. Sono aggregato sulla stessa riga di options

---

### FRAMMENTAZIONE E RICOMBINAZIONE
Utile introdurre una misura:
- **MTU**: Maximum Transmission Unit (valore massimo delle dimensioni del datagramma accettate dalla rete di inoltro su cui si appoggia il layer IP)

Facciamo un esempio numerico per capire:
Un host vuole inviare un datagramma su una rete TCP/IP di dimensione 4000 byte totali (payload + almeno 20 byte della testata)
- Si suppone che questo sia riferito a una rete $ethernet$ per la quale il formato accettato √® di $L_{M}=1500 \text{ byte}$.
Si deve quindi procedere alla frammentazione (essendo $4000 > 1500$)
##### VINCOLI:
- ogni frammento deve avere una propria testata IP 
- tutti i frammenti eccetto l'ultimo devono avere una lunghezza multiplo intero di 8 byte (se non lo sono, vanno completato con bit "fittizi", e nel caso quindi non si sfrutta al massimo la rete $\to$ svantaggio)
#### PROGETTO
Abbiamo che:
- $L_{M}=1500$
	- Di cui: $1480$ byte payload & $20$ byte testata 

Fortunatamente $1480$ √® un multiplo intero di $8$, quindi non c'√® bisogno di utilizzare alcun campo (bit) fittizio
#### frammentazione
Per gestire la frammentazione si deve definire il valore in binario dei seguenti campi (2¬∞ riga):
- Identificatore (ID)
- Flag
- Fragment offset (spiazzamento)
![[Pasted image 20220714163049.png|300]]
- si partiziona il contenuto informativo quando il pacchetto deve passare attraverso la rete Ethernet
	- i datagrammi di dimensioni pi√π piccoli (partizionati) hanno ciascuno il medesimo $header$
	- l'**end-user** esegue poi la **ricostruzione**

![[Pasted image 20220714163522.png|400]]

- Nota: il campo ID viene scelto in maniera aleatoria, e identifica come gi√† visto il datagramma (infatti tutti i frammenti hanno lo stesso ID)

üò°: ritardo consegna - l'operazione di frammentazione ha un suo tempo di esecuzione
üò°: sicurezza - un hacker esterno pu√≤ mandare pacchetti piccoli con numero di spiazzamento casuali o nulli o che magari si sovrappongono con quelli gi√† inviati/ricevuti (in modo che il sistema di ricezione, "confuso", collassa) {nell'IPv6 sar√† implementato in maniera pi√π intelligente};
üò°: poca flessibilit√†/tolleranza: se qualche frammento non arriva a destinazione, viene scartato l'intero pacchetto {solo se il livello trasporto usa TCP si pu√≤ avere speranze di recupero}


### INDIRIZZAMENTO
- Sintassi per scrivere i campi del datagramma volta a una migliore gestione degli indirizzi IP in generale

Un indirizzo IP (4 byte - 32 bit) √® suddiviso in due parti:
- $\text{NET ID}$: identifica la **rete** di appartenenza del terminale host
- $\text{HOST ID}$: identifica lo specifico terminale (**host**) all'interno di una rete

Ci sono varie modalit√† di divisione/indirizzamento, vediamo le principali:
#### INDIRIZZI BASATI SULLE CLASSI
- 5 classi: $\text{A,B,C,D,E}$
	- Sono utilizzati per scopi comuni solo le prime $3$, ovvero: $\text{A,B,C}$
![[Pasted image 20220714164844.png|400]]
- Ogni classe ha un suo "metodo di divisione dei bit" circa i campi NET ID e HOST ID

- Se il primo bit √® $0$, allora √® di classe $\text{A}$, altrimenti se vale $1$ pu√≤ essere solo $\text{B,C,D,E}$
- Se i primi due bit sono $10$, allora √® di classe $\text{B}$, altrimenti se sono $11$ pu√≤ essere solo $\text{C,D,E}$
- Se i primi tre bit sono $110$, allora √® di classe $\text{C}$, altrimenti se sono $111$ pu√≤ essere solo $\text{D,E}$
- Se i primi quattro bit sono $1110$, allora √® di classe $\text{D}$, altrimenti se sono $1111$ pu√≤ essere solo $\text{E}$

La classe $\text{A}$ √® destinata ad applicazioni con:
- Poche reti
- Numero alto di Host

La classe $\text{B}$ √® destinata ad applicazioni con:
- Pi√π reti
- Un po' meno host

La classe $\text{C}$ √® destinata ad applicazioni con:
- Tante reti
- Pochi host


üòÉ: standardizzato - pi√π facile per la macchina comprendere l'indirizzo
üò°: spreco di indirizzi - dato che ogni router dovrebbe assegnare un NET ID con potenziali indirizzi non utilizzati 

> Con la tecnica del **subnetting** si pu√≤ dividere il NET ID in pi√π parti, cos√¨ che bastano meno indirizzi gestire lo stesso numero di dispositivi, evitando sprechi inutili

### SUBNETTING
- Maschera di rete che partiziona l'insieme di HOST ID indirizzati in sottoinsiemi. Essi vengono associati allo stesso NET ID.

#### indirizzo senza classi
- I campi NET ID e HOST ID hanno dimensione variabili, non esistono quindi vincoli di dimensioni dei campi
üòÉ: pi√π flessibile
üò°: pi√π complicato per la macchina


#### NAT
- Network Address Translation (Traduttore Indrizzi di Rete)
Ad ogni **rete** viene assegnato un solo indirizzo IP
- Per le comunicazioni interne si utilizzano indirizzi privati, che hanno valenza cio√® solo all'interno della rete
- Quando un host della rete decide di aprire una comunicazione con un dispositivo esterno alla rete sorgente, si mostrer√† con l'indirizzo pubblico attribuito alla rete
	- üò°: diventa pi√π complicato in fase di ricezione capire l'esatto dispositivo che ha fatto una richiesta, perch√© appare solo l'indirizzo della rete
	- üòÉ: meno spreco di indirizzi - una rete con $n$ dispositivi ha bisogno solo di un unico indirizzo per interfacciarsi
	- 


#### NOTAZIONE DEGLI INDIRIZZI: DECIMALE PUNTATA
- 4 numeri (veicolati con il loro valore in binario) separati da un punto
Esempio:
![[Pasted image 20220714172139.png|500]]

Fissata la classe dell'indirizzo (esempio classe $\text{B}$), si assegna la possibilit√† di inserire gli indicatori di HOST ID e SUBNET ID nel campo originariamente previsto solo per le informazioni di HOST ID
- Prendendo la classe $\text{B}$ come esempio abbiamo $2$ byte da gestire per l'HOST ID. Con questa nuova modalit√† i medesimi $2$ byte possono essere gestiti per HOST ID e SUBNET ID
- Nota: i router leggono solo *i primi due campi* che rappresentano la rete (NET ID)
	- I $2$ byte suddetti della classe $\text{B}$ hanno una *importanza locale* (della sottorete in considerazione, perch√© verso l'esterno come detto si interfacciano con un unico indirizzo)

##### MASCHERA DI RETE (SUBNET MASK)
- Serve per definire i "confini" dei sottoindirizzi di una rete (NET ID)
- ==Vale $1$ nelle posizioni di SUBNET ID==
- ==Vale $0$ nelle posizioni di HOST ID==
L'esempio pi√π comune √® il seguente (classe $\text{B}$):
$$
255.255.255.0 \longleftrightarrow \underbrace{11111111.11111111}_{\text{NET ID}}.\underbrace{11111111}_{\text{SUBNET ID}}.\underbrace{00000000}_{\text{HOST ID}}
$$
In questo caso:
- I primi 2 byte sono dedicati a NET ID (per com'√® definita la classe $\text{B}$)
- Il terzo byte √® relativo al SUBNET ID
- Si lascia libero (solo) l'ultimo byte per indirizzare gli host locali (HOST ID)

Per poter *estrarre* le informazioni necessarie per gestire l'operazione d'inoltro ai router, per ogni rete raggiungibile abbiamo in memoria le maschere di rete associate
La **procedura** √® la seguente:
- AND logico per individuare le informazioni circa la maschera di rete (se trovo $0$ invece vuol dire che ho trovato le informazioni dell'host id)

Esempio:
Ad un campus universitario √® stato assegnato un indirizzo IP di classe $\text{B}$ seguente:
$$
150.10.0.0
$$
Avr√† maschera di sottorete, essendo di classe $\text{B}$:
$$
255.255.255.0 \longleftrightarrow \underbrace{11111111.11111111}_{\text{NET ID}}.\overbrace{\underbrace{11111111}_{\text{SUBNET ID}}.\underbrace{00000000}_{\text{HOST ID}}}^{\text{LOCALE}}
$$

#### INDIRIZZI SENZA CLASSI: COME VIENE GESTITO IL SUBNETTING
Vediamo con un esempio: si vogliono gestire $1000$ indirizzi ($10^{3}$) 
- Si devono assegnare rispettando la regola di avere un numero finale espresso come potenza di intera di due: avendo $1000$ indirizzi, avremo come riferimento $1024$, ovvero $2^{10}$ (quindi $10$ bit per l'HOST ID e i restanti $22$ per la maschera)
In notazione senza classi:
$$
\text{w.y.z.k}/n  \quad , \quad \text{nel nostro caso: } \text{w.y.z.k}/22
$$

### PROCEDURA DI INDIVIDUAZIONE DELLA SOTTORETE
Esempio:
- A una sottorete √® stato allocato un blocco di $1024$ indirizzi, cos√¨ localizzato:
$$
\text{da } 200.30.0.0 \quad \text{a } 200.30.3.255
$$
> Trovare la maschera di sottorete

- Traduciamo in binario
$$
\begin{gather}
200.30.0.0 &\longleftrightarrow &11001000.00011110.00000000.00000000 \\
200.30.3.255 &\longleftrightarrow &\underbrace{11001000.00011110.000000}11.11111111
\end{gather}
$$
Facendo l'AND logico, si ottiene la maschera di sottorete:
$$
\underbrace{255.255}_{\small \text{NET ID}}.\underbrace{252.0 }_{\small \text{sottorete }\to}\longleftrightarrow \underbrace{11111111.11111111}_{\text{NET ID}}.\underbrace{111111}_{\small \text{SUBNET ID}}\underbrace{00.00000000}_{\text{HOST ID}}
$$

==PROCEDURA DI ROUTING = Interrogazione a un database locale interno al Router==
Ogni router contiene in memoria (database):
- NET ID di ciascuna rete
- Una copia della maschera degli indirizzi delle reti

Ciascun router quindi che riceve un pacchetto:
- Legge l'IP di destinazione
- Esegue AND logico tra l'indirizzo e le tutte le maschere nel database del router corrispondenti (cfr. esempio successivo)
- In caso di "match" $\checkmark$ si identifica la porta del router a cui √® associato e il relativo indirizzo destinazione associato al router successivo posizionato meglio secondo l'algoritmo di routing utilizzato (da sovrascrivere nel campo $header$ del datagramma)
- Si reitera fino alla destinazione
- (se non c'√® corrispondenze: si manda tutto a un router di default finch√© TTL $\neq$ 0)

**Nota:**
Il matching pu√≤ portare ad ambiguit√†: accade cio√® che il match con un host dia luogo a corrispondenze multiple
- In tali casi si sceglie la corrispondenza con la maschera di sottorete pi√π lunga (con pi√π $1$): statisticamente infatti √® pi√π probabile che sia quello giusto

#### ALTRO ESEMPIO
Si assegnato i seguenti blocchi:
$$
\begin{gather}
\text{INFORMATICA} & 10000000 & 11010000 & 1xxxxxxx.xxxxxxxx\\
\text{ELETTRONICA} & 10000000 & 11010000 & 00xxxxxx.xxxxxxxx \\
\text{TELECOMUNICAZIONI} & 10000000 & 11010000 & 011xxxxx.xxxxxxxx
\end{gather}
$$
La struttura della rete sar√† la seguente (in decimale):
![[Pasted image 20220715002955.png|500]]

Quando arriva un pacchetto sul router $\text{A}$, esso deve capire qual √® la destinazione.
Esempio:
$$
128.208.2.151
$$
- Si effettua l'AND logico tra l'indirizzo suddetto e tutte le maschere delle sottoreti connesse/disponibili sul router

CASO 1:
![[Pasted image 20220715003733.png|400]]
CASO 2:
![[Pasted image 20220715003805.png|400]]
![[Pasted image 20220715003818.png|400]]


### ESEMPIO: DETTAGLIO SU TABELLE DI ROUTING
![[Pasted image 20220715004801.png|500]]

![[Pasted image 20220715004840.png|500]]

Le relative tabelle sono:
![[Pasted image 20220715004912.png|500]]
Da leggere come:
- Se arriva [INDIRIZZO/MASK]
- Allora inoltra a [PROSSIMO ROUTER]
- Sulla interfaccia [m_i]

In caso di match: fine (primi quattro casi)
Si noti come solo $m_{4}$ si interfacci a un nuovo router. Cio√® se arriva una richiesta da un indirizzo diverso da quelli descritti precedentemente, allora manda tutto sul router di default $\text{D}2$ attraverso l'interfaccia $m_4$ 

La tabella di $\text{D}2$ invece:
![[Pasted image 20220715005514.png|500]]
- In genere si associa l'indirizzo con la sotto maschera pi√π lunga

---
## DHCP
$Dynamic \ Host \ Configuration \ Protocol$
L'host attraverso questo protocollo acquisisce in maniera automatica (plug-in-play):
- L'indirizzo IP
- La Maschera di Rete (sottorete)
- Gateway (indirizzo router)

L'indirizzo √® dinamico perch√© pu√≤ cambiare col tempo (e viene concesso solo quando c'√® la necessita)

- Lo scopo √® quello di aumentare l'utilizzo degli indirizzi IP: solo chi √® attivo sulla rete possiede un indirizzo (non conviene vincolare un indirizzo IP esclusivamente per un dispositivo considerando che questo non sar√† sempre collegato sulla rete)
	- In questo modo in generale (non contemporaneamente): $\text{\# utenti gestiti } > \text{ \# indirizzi}$


Serve un apposito **server DHCP** associato alla rete
- Il DHCP quindi √® un protocollo ==**$client \text{-}server$** ==in cui il $client$ √® il dispositivo che richiede di connettersi

![[Pasted image 20220715010312.png|500]]
- Il client si fa identificare
- Il server (o anche pi√π di uno) risponde (rispondono) con una o pi√π offerte (di indirizzo, banda, durata etc...)
- Il client quindi sceglie una delle offerte e lo comunica al server
- Il server conferma (se l'indirizzo √® ancora disponibile) con un acknowledgement

Vediamo come sono fatti i singoli messaggi scambiati:

#### MESSAGGIO DI IDENTIFICAZIONE (dhcp discovery)
Un dispositivo nuovo nella rete:
- Non ha indirizzo IP
- Non sa dove si trova il server DHCP

Per tali ragioni, il messaggio viene inviato in **broadcast $255.255.255.255$**, con indirizzo sorgente $0.0.0.0$
- Il messaggio ha in allegato un *identificatore* che identifica in maniera univoca la richiesta (e quindi il client che l'ha fatta)
	- Il campo identificatore della richiesta √® detto $transaction \text{-}id$ ed √® lungo $4 \text{byte}$
		- La prima volta viene scelto in modo casuale
- Il datagramma viene inviato utilizzando UDP con porte sorgente-destinazione: $68\text{-}67$
	- La porta √® una entit√† logica (etichetta) che ci permette di separare i datagrammi in relazione al servizio a cui si riferiscono (utile soprattutto ai livelli superiori)

#### MESSAGGIO DI offerta (dhcp offer)
Viene generato in risposta a una richiesta di accesso.
Contiene le seguenti informazioni:
- $transaction \text{-}id$ sorgente
- L'indirizzo proposto
- La maschera di rete 
- Tempo di validit√† dell'offerta

Il messaggio viene mandato in broadcast nuovamente con UDP (porte $67 \text{-}68$)

#### MESSAGGIO DI RICHIESTA (DHCP REQUEST)
Il client sceglie l'offerta pi√π conveniente e comunica:
- Al server scelto che ha accettato l'offerta
- Agli eventuali altri server che ha accettato una offerta diversa

Questo lo effettua inviando il messaggio specificando gli attributi univoci dell'offerente scelto. Viene mandato in broadcast. Chi riconosce nel messaggio l'offerta fatta comprende di essere stato selezionato (gli atri sanno di essere esclusi)
- Nota: per fini commerciali e di sicurezza, non si utilizza l'IP assegnato come sorgente

#### MESSAGGIO DI CONFERMA (DHCP ACK)
Il server DHCP informa il client che l'indirizzo scelto √® ancora disponibile e pu√≤ cominciare a utilizzarlo

**Bonus**: se l'offerta per qualche motivo √® saltata (ad esempio se l'indirizzo IP proposto non √® pi√π disponibile), il server lo comunica inviando un messaggio detto $\text{DHCP-HACK}$ in broadcast


## NAT
$Netword \ Address \ Translation \ (Traduzione \ Indirizzi \ Di \ Rete)$

Un ISP in generale deve gestire un numero di utenti ben superiore al numero di indirizzi che ha a disposizione. Per tale ragione si utilizza il NAT che permette di assegnare un unico indirizzo IP di "interfacciamento verso l'esterno" per una intera rete
In questo modo:
- All'interno della rete si continuano ad utilizzare gli indirizzi privati
- Quando si vuole interfacciarsi con l'esterno lo si fa attraverso un unico indirizzo (gateway) assegnato dall'ISP


Gli **indirizzi privati** sono divisi come segue:
![[Pasted image 20220715124143.png|500]]

Il NAT permette la traduzione grazie a una apposita **tabella di matching**, in cui in essa si associa ciascun indirizzo privato della rete con il relativo indirizzo pubblico

### FUNZIONAMENTO
![[Pasted image 20220715125606.png|500]]

- Un dispositivo manda il suo datagramma verso il router NAT
- Il server NAT associa l'indirizzo (in questo caso appartenente alla prima famiglia) con l'indirizzo pubblico e traduce anche il numero di porta, mettendone uno associato in maniera univoca al client che ha richiesto l'uscita (questo risolve quelle ambiguit√† in cui due host della stessa rete richiedono lo stesso servizio: in quel caso se il NAT non assegnasse una porta "fittizia" e non la salvasse nella sua tabella, poi dopo non saprebbe in fase di ricezione a chi indirizzare i successivi datagrammi in risposta)

üò°: il processo di traduzione richieste un certo tempo $t$ di esecuzione
üò°: il matching in tabella avviene in fase d'invio verso l'esterno, ma se prima arriva una richiesta dall'esterno, il NAT poi non sa a chi mandare il datagramma di preciso perch√© non ha salvato nulla sul database locale
	- üòÉ: risolto con il NAT trasversale (server specifico pi√π complesso)
	- üòÉ: specificando le porte relativo al servizio che si vuole atturare √® pi√π facile individuare l'host di destinazione della rete privata
üò°: il serve NAT rende la rete *centralizzata*: a causa di questo, se si dovesse rompere per qualche motivo, l'intera rete non potrebbe pi√π interfacciarsi verso l'esterno
	- üò°: problemi quindi di affidabilit√† e sicurezza (pensiamo a un hacker che butta gi√π il server)

## IPv6
Introdotto a causa della carenza d'indirizzi a tutte le nuove necessit√† di poter gestire i servizi in modo pi√π efficiente. Permette anche di implementare alcuni servizi specifici in maniera pi√π concreta rispetto a IPv4 (ad esempio la sicurezza, che viene inserita nel campo dati di IPv6, invece che nel campo Options di IPv4)

- üòÉ: Meno campi da interpretare (e quindi meno controlli, meglio... pi√π veloce la lettura nei routers), ma stesse funzionalit√†
![[Pasted image 20220715145709.png|500]]

#### DESCRIZIONE DEI CAMPI
- **Version** (4 bit): specifica la versione del protocollo
- **Traffic Class** (8 bit): simile al campo TOS di IPv4 $\to$ specifica il tipo di traffico/servizi che si devono gestire
- **Flow Label** (20 bit): [etichetta di flusso] - serve per distinguere i flussi di datagrammi quando questi sfruttano lo stesso servizio. Consente la piena gestione di questi pacchetti in fase di inoltro, con un criterio definito a seconda del caso. Questa filosofia riguardo la modalit√† di inoltro ricorda molto il $connection \ oriented$ 
	- üëÄ: questa cosa va un po'contro l'idea di IP protocolo che √® nato connection less
- **Payload Length** (16 bit): lunghezza della parte dati del datagramma (dimensione totale meno header) - $2^{16}-1=65535$ possibili combinazioni. $Nota:$ l'header ha lunghezza fissa di 40 byte
- **Next Header** (8 bit): specifica l'intestazione della parte dati successiva e pu√≤ riferirsi a protocolli di livello superiore (trasporto), come il TCP {fa tutto parte del payload}
- **Hop Limit** (8 bit): sostituisce il TTL dell'IPv4

==Nota: Manca il campo $checksum$ che proteggeva da errori le informazioni della testata==
- üòÉ: Elaborazione pi√π veloce (non devo ricalcolarlo tutte le volte che si cambia la testata)
- üò°: Si suppone per√≤ che in ogni trasferimento non si abbiano errori o mis-match 
	- üîù: rischio apparentemente alto, ma si ipotizza al ccontempo che si utilizzino mezzi di trasmissione di qualit√† superiore

> [!question] Come si comporta IPv6 con reti non omogenee e quindi con la **frammentazione**?
> Notiamo che non ci sono campi dedicati nel datagramma all'operazione di frammentazione, quindi ci chiediamo ad esempio *come si realizza la compatibilit√† di formato su tutto il percorso end-to-end che coinvolge reti* non omogenee (cio√® *con formato di trasporto diverso*)*?*
> > In IPv4 la frammentazione avviene all'occorrenza, cio√® con modalit√† *link-to-link*: quando i datagrammi sono troppo grandi il router li frammenta (il mittente non √® a conoscenza di ci√≤)
> 
> > In IPv6 la frammentazione avviene in modalit√† **end-to-end**: prima dello scambio di dati, si scopre la dimensione massima di trasferimento in tutto il percorso attraverso un protocollo detto *MTU discovery*. In questo modo la sorgente individua il valore pi√π piccolo e implementa gi√† lei (in partenza) la frammentazione che poi sar√† gestita in fase di ricezione

> [!abstract] Novit√† IPv6
> Riassumendo, le novit√† di IPv6 rispetto a IPv4 sono:
> - Assenza del campo checksum
> - Frammentazione con filosofia end-to-end invece di link-to-link
> - Indirizzamento pi√π ampio (vedi dopo)

 ### INDIRIZZAMENTO
 Abbiamo a disposizione un campo indirizzo esteso: 16 byte (contro i 4 byte di IPv4)
 Il tipo di indirizzamento prevede 4 modalit√†:
 - Multicast (da uno verso molti: un indirizzo verso tanti destinatari - se tutti i destinatari allora broadcast)
 - Unicast (un indirizzo verso un destinatario)
 - Anycast (indirizzo IP condiviso, cio√® con pi√π corrispondenze all'interno della rete)
	 - Quindi, se una interfaccia pu√≤ avere pi√π indirizzi IPv6, il NAT non ha pi√π utilit√† (se necessario basta attribuire un nuovo indirizzo, non ci sono problemi di carenza)

Gli indirizzi sono espressi in esadecimale, ad esempio:
$$
\text{2001:0db8:85a3:0000:0000:8a2e:0370:7334}
$$
#### SINTASSI UNICAST ipv6
Si identifica in modalit√† univoca una sola interfaccia di rete
Ha una sintassi **gerarchica**
![[Pasted image 20220715162616.png|500]]
- Global Routing Prefix: identifica una area molto estesa - 48 bit
- Subnet-Id: identifica una rete di pi√π piccole dimensioni - 16 bit
- Interface-Id: detto anche Host-ID, identifica un singolo dispositivo appartenente a una subnet - 64 bit

Esino anche indirizzi unicast specifici:
##### INDIRIZZI LINK LOCAL
Utilizzati solo su base link, cio√® tra dispositivi *direttamente connessi*
##### INDIRIZZI SITE LOCAL
Utilizzato come indirizzi privati, ovvero per connessioni tra dispositivi di una stessa rete/sito (non sono accessibili dall'esterno)


## CONFRONTO HEADER IPv4 vs HEADER IPv6
- Campo IHL non presente in IPv6: le testate hanno tutte lunghezza uguali, cio√® 20 byte (specificava la lunghezza dell'header). Eventuali estensioni di dimensione sono eseguite nella parte dati (payload)
- Campo Protocol rimosso in IPv6 perch√© il protocollo di livello TCP √® specificato nel campo $next \ header$, situato nella parte dati (payload)
- Campi legati alla frammentazione assenti in IPv6 perch√© tale operazione √® effettuata in modalit√† end-to-end (non serve quindi trasferire le informazioni lungo il tragitto - viene gi√† fissato tutto in precedenza con MTU discovery)
- Checksum non presente (si auspica di star utilizzando mezzi di trasmissione di qualit√† con bassa probabilit√† di errore)

üòÉ: IPv6 pi√π veloce e flessibile (e quindi pi√π adatto alle nuove esigenze) - durante il tragitto i datagrammi passano molto pi√π velocemente attraverso ai routers perch√© vengono effettuati meno controlli
üòÉ: ha risolto definitivamente (?) la carenza di indirizzi


## PASSAGGIO IPv4 $\to$ IPv6
Cambiare standard non √® una cosa semplice.
Bisogna perci√≤ adattarsi al caso.
Risulta di fondamentale importanza rendere **retrocompatibili** i sistemi IPv6 con i precedenti IPv4
Sono state sviluppate due tecniche a riguardo:
- DUAL STACK (doppia pila)
- TUNNELLING

### DUAL STACK
![[Pasted image 20220715165335.png|400]]

Struttura che implementa entrambe le versioni a livello rete: si associa a un indirizzo IPv4 un indirizzo IPv6 (eseguendo una conversione grazie all'utilizzo di un router/gateway), risalendo la pila fino allo strato TCP con un protocollo e poi riscendendo con un altro

üòÉ: facile da implementare
üò°: non risolve il problema della carenza di indirizzi IPv4
üò°: conversione al contrario (IPv6 $\to$ IPv4) si perdono funzionalit√†: abbiamo meno informazioni in testata (invece ci√≤ che si perde in IPv4 $\to$ IPv6 viene integrato con servizi pi√π evoluti). Questo porta ad esempio l'impossibilit√† di gestire alcune parti/funzionalit√† (come il *flow label*, ovvero la gestione dei flussi: no possibilit√† di classificare i flussi a seconda delle esigenze di servizio)
üò°: si deve utilizzare un router/gateway (costi + prestazioni elevate)

#### ESEMPIO:
![[Pasted image 20220715171333.png|500]]
![[Pasted image 20220715171506.png|500]]


### TUNNELING
![[Pasted image 20220715172016.png|500]]
