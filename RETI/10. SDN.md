# SDN
$Software \ Defined \ Network$
- Reti basate sul software

### INTRO
La rete IP, soprattutto quando l'utilizzo diventa intenso (come al giorno d'oggi) spesso non √® sufficiente. Essa offre soluzioni non al livello delle richieste
	Pensiamo ad esempio all'instradamento e a tutti i problemi che possono derivare

Per avere un sistema pi√π flessibile, meno complesso e che possa avere una certa intelligenza interna per reagire a problemi esterni sono state pensate reti pi√π avanzate
	Esse si caratterizzano per gestire in modo separato le parti di:
		- Hardware (router, switch) e relative politiche di inoltro
		- Controllo (intelligenza per inoltrare in modo opportuno)

Le **SDN** ha rotto la filosofia "verticale" dei $layers$ della rete, creando un nuovo paradigma:
	Esso introduce astrazioni e modellizzazioni della rete che facilitano la gestione della rete stessa 

Fin ora abbiamo visto tecniche di instradamento classiche, come distance vector e link state che avevano come obiettivi quello di popolare un DB locale del router su cui salvare tutte le informazioni utili per la successiva scelta ottimale per l'inoltro di una informazione da una certa sorgente a un destinatario
	Nota: il DB locale pu√≤ essere anche riempito "manualmente", cio√® un tecnico addetto pu√≤ individuare i percorsi che ritiene migliori e implementarli - tuttavia questa procedura √® lenta e poco flessibile

### APPROCCIO SDN
Come detto le SDN considera separati per l'utilizzo la parte Hardware da quella di Controllo (intelligenza). Quest'ultima parte viene intesa in primo luogo in modo "logicamente centralizzata" - ovvero abbiamo una parte di controllo (Cloud) paragonabile come al cervello della rete
Per capire meglio la divisione delle parti:
![[Pasted image 20220720120013.png|500]]
- Network Infrastructure: dove risiedono i dispositivi fisici (Hardware)
	- Con la differenza che a cose normali ogni router ha la propria parte intelligente, cio√® il proprio software che si impegna alla fase di calcolo. In questo caso invece il router √® *programmabile* e quindi adattabile alle esigenze - attraverso i comandi della parte intelligente della rete, ovvero il Controller Platform
- Controller Platform: come detto √® la parte intelligente della rete, idealmente remota (Cloud) che si interfaccia con il livello sottostante mediante una apposita interfaccia detta $southbound$ (inferiore) - grazie ad applicazioni software che permettono di trasferire i comandi. Il piano di controllo interagisce a sua volta con quello delle applicazioni
- Network Application(s): Piano applicazioni - interfacciato con il livello di controllo attraverso l'interfaccia $northbound$ (superiore). Ogni applicazione comanda il piano inferiore di controllo chiedendo specifiche azioni che sono quindi "trasdotte" (convertite, adattate) per i dispositivi dentro la Network Infrastructure.
	- Ad esempio, pu√≤ richiedere l'implementazione di politiche di gestione del flusso oppure gestire l'attivazione degli algoritmi di routing

$Diagramma \ alternativo:$
![[Pasted image 20220720132151.png|400]]

### INOLTRO GENERALIZZATO SDN
- Sappiamo che gli algoritmi di routing, come l'MPLS, consentono funzionalit√† aggiuntive tra cui ad esempio distinguere il tipo di traffico da inoltrare, in relazione a specifiche richieste di servizio (attraverso l'uso di etichette). L'utilizzo di MPLS √® tuttavia un $middleware$, cio√® un livello intermedio che non pu√≤ essere implementato direttamente al livello IP (causa poca capienza testata datagrammi IP), situato tra il livello collegamento e il livello IP $\to$ questo porta a fare qualcosa di "fuori logica" rispetto a quanto sappiamo coi livelli, principalmente perch√© l'instradamento avviene utilizzando informazioni di livello inferiore
- Viceversa il NAT permette l'instradamento andando a leggere i numeri di porta del livello superiore 
- Anche il firewall

> L'SDN consente invece di attuare tutte queste (e altre) possibilit√† *in modo unificato*: senza usare cio√® protocolli specifici al caso, ma con **applicazioni generali** che vengono adattate secondo le richieste di servizio üòÉ

- Le operazioni effettuate nel routing tradizionale sono due:
	- Ricerca indirizzo IP di destinazione (analizzando ed estraendo la maschera di sottorete nel datagramma) $\to$ $\boxed{match}$
	- Inoltro (invio) effettivo del pacchetto  $\to$ $\boxed{action}$

> Nel caso di SDN queste operazioni sono **integrate**: un $match$ corrisponde a una $action$ 
> Avviene cio√® tutta sullo *stesso livello* e sullo stesso "programma" di gestione

##### ALGORITMO DI ROUTING IN SDN
![[Pasted image 20220720122452.png|500]]

- Nel routing tradizionale, tutte le azioni rimanevano confinate nel piano Infrastructure - cio√® dei dispositivi fisici, che si scambiavano le tabelle per ricercare la soluzione ottima per il percorso sorgente-destinazione (basandosi su un certo algoritmo)
	- Realizzazione distribuita: tutti i router collaborano per le tabelle

> Nelle SDN gli algoritmi rimangono gli stessi, ma ciascun dispositivo non comunica pi√π con i propri vicini rimanendo a livello infrastructure, ma viceversa *comunica con un cloud (controller) remoto* (quindi di livello superiore) - dove appunto gli algoritmi risiedono nel piano applicazione: essi eseguono i calcoli da fare e poi vengono quindi trasferite ai router le tabelle di instradamento trovate $\to$ realizzazione centralizzata

- Nel routing tradizionale, ci si basa sull'indirizzo di destinazione per progettare i relativi percorsi sorgente-destinazione per effettuare appunto il routing
> Invece in SDN √® previsto una generalizzazione dell'operazione di routing: ci si basa non pi√π solo sull'indirizzo di destinazione, ma ci sono pi√π funzionalit√† per aumentare le prestazioni - il routing si effettua analizzando una *stringa (successione) di campi*

##### OPEN-FLOW
Standard interpretabile sia come un *linguaggio di programmazione* (perch√© serve per costruire le tabella di routing) ma anche come un *protocollo di comunicazione* (perch√© permette il trasferimento i risultati delle tabelle di routing dal controller (Cloud) alla rete)

##### PACKET-SWITCH
- Non si parla pi√π di switch o router ma di $packet \ switch$ (commutatore di pacchetto) - essi devono seguire le azioni che sono contenute nella tabella dei flussi ($flow \ table$) che risiede in OpenFlow

##### NO RISCONTRO
Se un pacchetto non trova riscontro nella relativa tabella dei flussi, allora esso viene inviato a una entit√† che effettua un controllo pi√π approfondito - tale entit√† pu√≤ essere il Controller remoto o un dispositivo preposto pi√π specifico

##### CONTATORI
- Un qualcosa in pi√π negli switch
Sono dei dispositivi preposti a monitorare le richieste di inotro dei datagrammi su *determinate* rotte - controllano il traffico della rete
- Le informazioni che raccolgono vengono trasferite al Controller che le elabora e definisce e aggiorna le decisioni in base allo stato della rete
	- *L'insieme delle azioni* costituisce appunto il modo con cui il dispositivo operer√† - sono decisi dal Controller

#### MATCH
Con la logica OpenFlow, l'operazione di $match$ consiste nella analisi dei seguenti campi:
![[Pasted image 20220720124419.png|600]]

- Non solo il campo sorgente e destinazione (IP Src e IP Dst) ed eventualmente le testate IP (IP Proto e IP TOS) ma utilizza **anche** informazioni *provenienti da altri livelli* (cross-layer):
	- Collegamento (schede di rete MAC, tipo di rete Ethernet etc...)
	- Trasporto (un po' come avevamo gi√† visto col NAT)
	- Porta di ingresso


> Un $packet \ switch$ ha funzionalit√† superiori: pu√≤ funzionare da switch di livello due oppure anche di livello tre o quattro

- Attualmente OpenFlow ha esteso i campi esaminabili da $12$ (in figura, che gi√† sembravano tante) a $41$
	- Q: Ne risente la velocit√† di trasmissione? A: No, perch√© le velocit√† son sempre pi√π alte
	- Non se ne aggiungono altre proprio per non risentirne in velocit√†: $fai \ una \ cosa \ ma \ falla \ bene$

#### WILDCARD
Si pu√≤ abbinare a pi√π indirizzi di rete una stessa azione specificando un gruppo di indirizzi in maniera apposita, utilizzando degli asterischi.
Ad esempio: $$ 128.119.*.* $$
Trova corrispondenza con tutti i datagrammi che iniziano (primi 16 bit) con $128.119$ 


### AZIONI PREVISTE IN OpenFlow
##### INOLTRO
- Ripetere il datagramma sulla porta di uscita che si ritiene migliore per quella richiesta
- Pu√≤ essere programmato da un Controller remoto ed eventualmente modificato a seconda dei contesti (per esempio per evitare congestioni)
##### DROPPING (SCARTO)
- Possibilit√† di eliminare un pacchetto che non trova corrispondenza nelle tabelle
##### MODIFICA DEI CAMPI 
- Possibilit√† di modificare la testata dei vari datagrammi (ad esempio per effettuare la frammentazione)

### ESEMPI MATCH-ACTION IN OpenFlow
![[Pasted image 20220720125936.png|500]]
#### ESEMPIO 1
- Il controller √® gestito da OpenFlow. Con esso si relaziona con i client
- I client si accordano con OpenFlow

Abbiamo $6$ host che sono connessi a $3$ router
- Vediamo come sono scritte le tabelle $action$ in relazione a determinate richieste


> $H5$ e $H6$ devono inviare pacchetti a $H3$ e $H4$ 

- i pacchetti arrivano a $S3$
	- Supponiamo che essi non possano seguire la strada diretta $S3 \to S2$ ma devono passare da $S1$

- Abbiamo due indirizzi di rete che mirano a una stessa azione: ad esempio i pacchetti generati da $H5$ e $H6$ possono arrivare a $H4$

Il router $S1$ ha la seguente tabella $action$:
![[Pasted image 20220720130525.png|500]]
- L'interfaccia di ingresso √® la $1$ (vedi figura)
- La sorgente √® la rete "$.3$" (generica)
- La destinazione √® la rete "$.2$" (generici) $\to$ cio√® deve arrivare a $S2$
	- Buono mantenere generico perch√© devo leggere meno campi

A $S2$ invece si associa la seguente tabella
![[Pasted image 20220720130926.png|400]]
- Si nota come il router finale "toglie" la wildcard e specifica l'indirizzo preciso di destinazione, a seconda della richiesta

#### ESEMPIO 2: LOAD BALANCING
Si vogliono inoltrare verso la stessa rete pacchetti provenienti da host della stessa rete *facendoli fare percorsi diversi*
- Ad esempio: $h3 \Rightarrow S2 \to S1$ e $h4 \Rightarrow S2 \to S3 \to S1$ tutti con destinazione $S1 \approx 10.1.*.*$
Questo non era permesso con il tradizionale inoltro IP!
![[Pasted image 20220720131506.png|400]]

#### ESEMPIO 3: FIREWALLING
![[Pasted image 20220720131610.png|600]]


### CONSIDERAZIONI su SDN
L'introduzione "massiccia" di un software nell'ambito della rete ha portato nuovi scenari, permettendo la creazione di tecnologie come $Edge \ Computing$, $Fog \ Computing$ e in generale l'$Industria \ 4.0$ (automatizzazione processi industriali)


