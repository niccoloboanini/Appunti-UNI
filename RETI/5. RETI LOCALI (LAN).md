# RETI LOCALI (LAN)
Servizi di connessione contingentati verso un'area locale, cio√® geograficamente non estesa 
- Pensato decine di anni fa
- Vedi reti ring, bus, star, etc... (introduzione corso)
- Specifica livelli bassi (1 e 2)
- Si suppone che i dispositivi interni alla rete abbiano a disposizione *mezzi trasmissivi di qualit√†*
	- Infatti l controllo dell'integrit√† (che nella struttura OSI si effettua a livello collegamento su base link-to-link), qui viene inserita agli estremi (edge - base end-to-end) ed √® gestita dall'LLC (vedi dopo)

- Standard riferimento delle reti locali: IEEE 802, in particolare diremo $$ \text{IEE }802.\text{xxx}  \quad , \quad \text{xxx} \to \text{servizio da specificare}$$

> [!seealso] Architettura Protocollare $\textbf{802}$
> Fatta a strati (livelli)
![[Pasted image 20220716175444.png|150]]
> Higher Layer $\to$ non sono specificati (indica che l√¨ ci saranno i livelli pi√π alti della pila TCP)
> LLC $\to$ Logical Link Control
> MAC $\to$ Medium Access Control
> Fisico $\to$ livello pi√π basso
> ---
> Un altro modo di vederlo √® il seguente (fonte: Wikipedia):
> ![[Pasted image 20220718110101.png|150]] 


#### LLC (logical link control)
Strato comune a tutti gli standard IEEE introdotti (a differenza del MAC che √® caratteristico delle particolari reti LAN che esamineremo)
Ha il compito di verificare su base $end \text{-} to \text{-}end$ *l'integrit√† dei dati* ricevuti
- Non crea problemi come concetto se stiamo utilizzando mezzi "di fiducia", di qualit√† (come supposto all'inizio)

Definisce uno standard *unico* per tutte le reti LAN della famiglia IEEE 802
- cio√® va bene per tutte le tipologie di reti (LAN)

Gestisce/implementa le seguenti modalit√†:
- ==Connection less== non affidabile (senza riscontro)
	- Modalit√† detta logical data link (collegamento logico)
- ==Connection less affidabile== (con riscontro)
	- Modalit√† detta logical data link alternativo (collegamento logico alternativo)
	- In caso di errori si richiede il re-invio
- ==Connection Oriented== 
	- Modalit√† detta data link connection (collegamento effettivo e affidabile)


### CONFRONTO OSI vs IEEE
- Si noti come LLC sia lo stesso
- MAC invece specifica a seconda della topologia della rete (ethernet, ring, bus...) e del tipo di collegamento (Ethernet, Token Ring, Token Bus...)

![[Pasted image 20220716180912.png|500]]


## MAC
Livello con la caratteristica di avere la tecnica di *condividere l'accesso a uno stesso mezzo fisico* a pi√π utenti (in istanti diversi) utilizzando una tecnica specifica.
Esistono due grandi famiglie di queste tecniche:
![[Pasted image 20220716181906.png|500]]

- **Casuali**: il primo utente che accede al dispositivo ne diventa il possessore, senza preoccuparsi degli altri utenti che potenzialmente potrebbero accederci. Possibili collisioni (pensiamo se due utenti fanno richiesta contemporaneamente a una risorsa, o se un utente chiede l'accesso a una risorsa gi√† occupata) [i nodi non collaborano tra loro, sono indipendenti]
	- Tecniche di accesso casuale (cfr. approfondimenti dopo):
		- ALOHA
		- CSMA (usato in reti Ethernet)
- **Ordinate**: si stabilisce una regola che vale per gli utenti autorizzati ad accedere al servizio/dispositivo (esempio: schedulare una tabella per gestire i tempi di accesso circa l'utilizzi di un PC). In questo modo si evitano conflitti (collisioni)
	- Tecniche di accesso ordinato:
		- **FDMA***, **TDMA** (accesso multiplo a divisione di frequenza [FDMA] o tempo [TDMA]: simile ad esempio all'FDM/TDM, che divideva la banda/tempo_utilizzo di un canale in canali e ciascuno viene assegnato a un utilizzatore)
		- *CDMA* (Code Division Multple Access) $\to$ utilizzata oggigiorno soprattutto (pi√π complessa): sfruttano i segnali ortogonali e la loro correlazione $\displaystyle \int_{0}^{t} x(t)y(t) \,dt=0$ . APPROFONDIMENTO:Baster√† allora assegnare a ogni utente un segnale che rispetta tale propriet√† con tutti gli altri. In ricezione soltanto quando si considera l'integrale con la copia esatta del segnale che vogliamo estrarre avremo valore diverso da zero (gli altri saranno nulli). In questo modo abbiamo estratto ci√≤ che volevamo (nota: √® un caso ideale)
		- **POLLING**: scheduling ordinato secondo un criterio ben definito (vedi dopo)

---

### ==TECNICHE ORDINATE==

### POLLING (interrogazione)
Prevede invio di un *messaggio* con struttura nota che *abilita chi lo riceve* ad accedere al canale
- Per evitare conflitti sull'accesso √® necessario prevedere una mobilit√† di invio del messaggio adatta, che abiliti cio√® un solo (specifico) utente del gruppo

Ci sono varie modalit√† per effettuare ci√≤, ad esempio:

#### ROLL-CALL
Tecnica di tipo *centralizzato* - esiste una **entit√†** che si occupa di coordinare l'accesso di ne fa richiesta in modo ordinato. Letteralmente si traduce con $fare \ l'appello$ e infatti:
- Come quando l'insegnante recita l'appello: ogni utente viene interrogato seguendo un ordine prefissato (alfabetico ad esempio)
- Cos√¨ fa l'entit√† centrale: invia il messaggio di autorizzazione al primo user che ha nella lista (del database): l'utente riconosce il messaggio, lo trattiene e accede al canale. Terminata la fase di accesso il terminale dell'utente rilascia l'autorizzazione e lo comunica alla entit√† centrale rilasciando il messaggio che aveva trattenuto. Si procede quindi con le successive interrogazioni (se un utente non ha informazioni da riferire, rilascia subito il messaggio) 

![[Pasted image 20220716202922.png|300]]

üò°: tempo di non utilizzo della rete (tipo quando un utente poi non richiede il servizio quindi rilascia subito il messaggio), delay dei tempi di rilascio e tempo interrogazioni varie
	> Tecnica alternativa: esiste e si chiama Hub-Polling (vedi dopo)
	

#### hub-polling
Tecnica di tipo *distributivo* e cooperativo. Implementato su una struttura a bus
- L'entit√† centrale (Master) chiama la stazione pi√π lontana
- La stazione riceve l'autorizzazione e accede, rilasciando il messaggio
- Il messaggio viene rilasciato dalla stazione immediatamente pi√π vicina alla precedente
- Continua il "passaparola" fino a tornare al Master
![[Pasted image 20220716202752.png|300]]

In questo modo si *riducono al massimo i tempi di latenza*: il messaggio non deve tutte le volte ritornare al Master

##### MODALITA' (tempi) DI ACCESSO al canale (valide per entrambe le tecniche)
- Come i dispositivi gestiscono i tempi della fase di accesso una volta che √® stato autorizzato
Due modalit√†:
- **Gated** (limitato): Intervallo di tempo di accesso e quindi numero di pacchetti trasmessi non costante e fisso. 
	- Un nodo √® autorizzato a trasmettere soltanto quei pacchetti che risiedono nel proprio buffer "di accumulo", che si riempie nell'intervallo che intercorre tra due autorizzazioni successive. Quei pacchetti che giungono sul buffer di accumulo durante l'effettivo accesso (che dura un non predeterminato tempo, a seconda di quanto ci mettono a essere trasmessi) dovranno attendere il "turno" (autorizzazione) successivo per poter essere trasmessi
		- Viene prefissato solo un tempo massimo di accesso, oltre il quale si passa al nodo successivo (indipendentemente dallo svuotamento o meno del buffer di accumulo)
			- Tempo comunque limitato
üòÉ: accesso pi√π "democratico"
üò°: non conveniente sempre, spesso trasmissione troppo "spezzettata"
- **Esaustivo**: un nodo termina la sua fase di accesso solo quando non ha pi√π pacchetti da trasmettere (svuota cio√® tutto il suo buffer di accumulo obbligatoriamente, che si √® riempito nel tempo compreso tra due autorizzazioni successive).
	- Vengono trasmessi anche quelli che arrivano durante il tempo di accesso (a differenza del caso precedente)
	- Una volta inviato tutto, se poi pian piano si riaccumula il buffer, tali pacchetti saranno (tutti) inviati alla "iterazione" successiva
	- Non si introducono limitazioni di tempo/pacchetti
üòÉ: accesso pi√π veloce
üò°: rischio di tempo di traffico molto alto - monopolizzazione (altri utenti non contenti)

### TOKEN PASSING
- Tutti i nodi della rete si passano un messaggio detto $token$ (gettone)
- Implementata su rete di tipo $ring$ (ogni nodo ha un predecessore e un successore)
- Il $token$ autorizza un nodo all'accesso. Terminata la fase, il gettone viene passato all'utente successivo

### ==TECNICHE CASUALI==

### ALOHA
- Tecnica di accesso concorrente (cio√® casuale appunto) su uno stesso punto ($access \ point$)
- Implementata su reti a stella
	- Il centro stella √® il suddetto punto di acceso "voluto" da pi√π user
![[Pasted image 20220718124815.png|300]]
- Il canale utilizzato √® quello *wireless* (radio)

##### ALOHA PURO
Nella modalit√† $base$ (puro), non prevede alcun coordinamento preventivo tra gli utenti (cio√® ognuno accede al canale quando ne ha necessit√†, senza preoccuparsi degli altri)
- üò°Causa inevitabilmente (possibili) **collisioni**: almeno due segnali generati da utenti diversi sono contemporaneamente presenti nel canale condiviso
	- Il segnale risultante quindi √® la somma dei due, pertanto diventa non interpretabile (perch√© disturbato)
	- Spreco di tempo ed energia

![[Pasted image 20220718125323.png|300]]
Per evitare il problema delle collisioni, o almeno ridurlo al minimo, dobbiamo chiederci:
- Q: Come si riconoscono le collisioni?
	- A: Si utilizza il **riscontro** dei tentativi. Infatti gli user provano ad accedere utilizzando una certa banda di frequenza. L'access point notifica in modalit√† broadcast l'esito del tentativo con una banda di frequenza diversa (per non creare sovrapposizioni con l'altra) e notifica tutti i client che hanno richiesto l'accesso ($Nota$: ogni utente conosce a priori quanto tempo deve passare tra la richiesta e il riscontro, perch√© √® ben definito per tutti un certo tempo di $timeout$).
		- Se tutto va bene, allora vuol dire che i client hanno ricevuto il riscontro entro la finestra temporale prevista
		- Se c'√® qualche problema, vuol dire che nell'intervallo previsto i client non hanno ricevuto alcun riscontro $\to$ accesso non avvenuto
- Q: Come si risolvono le collisioni?
	- A: Vedi $(**)$

Quindi: tempo di pericolo uguale al doppio del tempo di pacchetto (collisioni che possono avvenire in tutto il tempo di pacchetto del client che ha gi√† l'accesso e che durano per tutta la durata di accesso del nuovo client)
üò°: basso utilizzo della rete efficiente (si parla del $18\%$)

##### ALOHA SLOTTED
- Introduce un minimo coordinamento: gli host possono accedere solo in precisi istanti temporali  
![[Pasted image 20220718131206.png|300]]
Cio√® ad esempio nei punti indicati dalle frecce

Se un utente richiede l'accesso durante uno slot (freccia celeste) gi√† occupato, non accede immediatamente, ma attende per il prossimo istante temporale di riferimento utile per l'accesso (prima freccia rossa, che indica anche la fine per il segnale che attualmente occupa il canale). In questo modo l'accesso sar√† esclusivo
![[Pasted image 20220718131402.png|200]]

- Nota: ci saranno ancora collisioni se le richieste son tante (vedi figura)
![[Pasted image 20220718131626.png|200]]

Quindi:
tempo di pericolo pari a un singolo tempo di pacchetto (richieste concorrenti solo nell'intervallo di tempo occupato dal pacchetto che ha gi√† l'accesso sul canale)

üòÉ: rendimento il **doppio** migliore rispetto ad Aloha Puro (si parla del $36\%$ di utilizzo in media)


> [!todo] Risolvere le collisioni: analisi statistica
$(**)$
- Prendiamo come riferimento Aloha Slotted

> Dato che la collisione coinvolge almeno due client, una volta notificato a essi dell'avvenuto problema √® necessario implementare un sistema di coordinamento per evitare che richiedano immediatamente l'accesso, causano nuove collisioni e cos√¨ via.

- L'idea √® quella di *schedulare* le fasi di accesso
	- Modalit√† di tipo statistico (alternativamente detto casuale) personalizzata a ogni utente

	- üòíCi immaginiamo in primis una distribuzione Gaussiana: in questo caso avremmo un grosso addensamento di scelte centrato sul valor medio della distribuzione (in questo caso intorno allo $0$) - ovvero probabilit√† alta che due utenti vadano nuovamente a scegliere *uno stesso istante di accesso* $\to$ non realistica, perch√© *non equamente probabile su ogni istante di tempo*
![[Pasted image 20220718134305.png|200]]
	- üòâLa **distribuzione uniforme** √® quindi quella pi√π adatta: tutti gli istanti hanno la stessa probabilit√† di essere scelti come istante di accesso. Scegliamo quindi questa $\checkmark$
	![[Pasted image 20220718134506.png|300]]

----
---

## CSMA
$Carrier \ Semsing \ Multiple \ Access$: tecniche ad accesso multiplo con rivelazione di portante

- Topologia di rete a bus associata a queste tecniche

Prevede una **fase iniziale** preventiva all'accesso stesso che ha l'obiettivo di individuare la presenza di *attivit√† del canale*
- Viene realizzata andando a ricercare all'interno del canale la presenza del **segnale portante**, ovvero quella frequenza che trasporta l'informazione *dati* - √® un tono ben preciso (e riconosciuto), quindi quando lo si ricerca si individua bene e significa proprio che qualcuno sta utilizzando quel canale.
	- Se ci si accorge di ci√≤, *non* si accede al canale (evitando collisioni)
		- Se √® presente attivit√† sul canale ma non si accede effettivamente allo stesso, si parla di *collisione virtuale*. Dopodich√© si riprogramma un accesso con le stesse modalit√† di Aloha Slotted (cio√® su un intervallo statisticamente uniforme detto di $take \text{-} off$) 

üòÉ: evito collisioni
üò°: tempi di propagazione di un segnale sul supporto. Sono piccoli, ma mai nulli: la fase iniziale potrebbe introdurre ritardi (vedi dopo)

> [!danger] Tempi di Propagazione del Segnale: possibile svantaggio concreto?
> Supponiamo di trasmettere pacchetti di durata $\tau$ ciascuno
> Si considerino ora due stazioni $\text{A},\text{B}$ distanti tra loro un tempo $\delta$
> ---
> >Ipotizziamo quindi che sia $\text{A}$ che $\text{B}$ decidano di accedere al canale all'istante $t_{0}$
> Dato che il canale si suppone libero, entrambi trovano il canale disponibile (non rilevano segnali portanti) 
> 
> $\text{A}$ accede e trasmette quindi un pacchetto di durata $\tau$ (secondi) a partire da $t_{0}$
> ![[Pasted image 20220718140812.png|200]]
> $\text{B}$ ha fatto lo stesso, cominciando a trasmettere da $t_{0}+\delta$, ma i due tra loro non se ne sono accorti. In particolare, guardando dal punto di vista di $\text{A}$, essa si accorgerebbe della presenza di $\text{B}$ solo $\delta$ secondi dopo.
> Dato che anche il secondo pacchetto ha durata $\tau$, allora $\text{B}$ ha trasmesso nell'intervallo $[t_{0}+\delta \div t_{0}+\delta+\tau]$. Riassumendo graficamente:
> ![[Pasted image 20220718141330.png|250]]
> La distanza $\delta$ √® quindi **l'intervallo di pericolo** (vulnerabilit√†), perch√© appunto le due stazioni non si accorgono l'uno dell'altro per una finestra temporale pari a $\delta$
> > [!success] Pertanto, si auspica per avere i vantaggi delle reti CSMA che $\delta$ sia *pi√π piccolo possibile*, ovvero vorremmo $$\large \boxed{\delta << \tau}$$
> 







